# ?ECMAScript modules

По мере роста нашего приложения, мы обычно хотим разделить его на много файлов, так называемых «модулей». _Модуль_ – это просто файл. Модули используют директивы `export` и `import`, чтобы обмениваться функциональностью:

* `export` отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
* `import` позволяет импортировать функциональность из других модулей.

Необходимо явно сказать браузеру, что скрипт является модулем, при помощи атрибута `<script type="module">`. Браузер автоматически загрузит модуль (и те, которые он импортирует), а затем запустит скрипт. Чтобы работало через `Node.js`, то в `package.json` добавляем `«type»: «module»`.

##### Особенности модулей:

* В модулях всегда используется режим `use strict`. Например, присваивание к необъявленной переменной вызовет ошибку.
* Каждый модуль имеет свою собственную область видимости.
* Модули, даже если загрузились быстро, ожидают полной загрузки HTML документа, и только затем выполняются. Обычные скрипты запускаются раньше, чем модули.
* Сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.
* `this` в модуле не определён.
* Работает атрибут `async`. `<script async type="module">`
* Код в модуле выполняется только один раз при импорте.

##### Виды экспорта:
* Экспорт до объявления. Мы можем пометить любое объявление как экспортируемое, разместив export перед ним, будь то переменная, функция или класс. Экспортируемые средства должны быть определены в области видимости верхнего уровня.

`export const month = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul","Aug", "Sep", "Oct", "Nov", "Dec"];`

* Экспорт отдельно от объявления

~~~
function sayHi(user) {
  console.log(`Hello, ${user}!`);
}

function sayBye(user) {
  console.log(`Bye, ${user}!`);
}

export { sayHi, sayBye };
~~~

* Экспортировать "as", чтобы экспортировать под другими именами.

~~~
...
export { sayHi as hi, sayBye as bye };
~~~

* Экспорт по умолчанию. В файле может быть не более одного export default. И потом импортируем без фигурных скобок.

`class Animal {}`
`export default Animal;`

или

`export default class Animal {}`

но не

`export default user = 'Mary';` так как метка `export default` неприменима к объявлению переменных.

Правильный вариант - `export default 'Mary';`

Реалистичный сценарий - экспорт объекта, содержащего несколько средств.

~~~
class Animal {}
class Cat {}
export default { Animal, Cat }
~~~

Импортируем так:

~~~
import module from "./script.js";
console.log(module.Cat);
~~~

* Реэкспорт. Чтобы пути импортов не были слишком длинными, можно использовать реэкспорты — когда мы внутри файла импортируем функциональность из одного модуля и сразу же экспортируем её из него.

`export { Animal } from "./script.js";`

Чтобы реэкспортировать средство по умолчанию, нужно обратиться к нему по имени default:

`export { default } from "./script.js";`

Можно реэкспортировать все средства из другого модуля, кроме средства по умолчанию:

`export * from "./script3.js"; // Экспортируем, находясь в script2.js`

И импортировать так:

`import * as module from "./script2.js"; // Импортируем, находясь в script.js`

##### Виды импорта:

* Импорт по умолчанию. Мы можем изменить имя импортируемого средства.

`import x from "module";`

`import { default as x } from "module";`

* Если импорт не по умолчанию, то мы располагаем список того, что хотим импортировать, в фигурных скобках `import {...}`

~~~
import {sayHi, sayBye} from './say.js';

sayHi('John'); // Hello, John!
sayBye('John'); // Bye, John!
~~~

* Мы также можем использовать `as`, чтобы импортировать под другими именами. Скобки обязательны.

~~~
import { sayHi as hi, sayBye as bye } from './say.js';

hi('John'); // Hello, John!
bye('John'); // Bye, John!
~~~

* Динамический импорт. Загрузка в этом случае происходит асинхронно.

`import("./script.js");`

* Если импортировать нужно много чего, мы можем импортировать всё сразу в виде объекта:

~~~
import * as module from "./script.js";
console.log(module.Cat);
console.log(module.default); // чтобы обратиться к средству, экспортированному по умолчанию
~~~

* Импорт всего модуля, не импортируя что-либо. Это запускает глобальный код модуля, но в действительности не импортирует никаких значений.

`import "./script.js";`
