# ?Catastrophic backtracking

Некоторые регулярные выражения, простые с виду, могут выполняться оооочень долго, и даже «подвешивать» интерпретатор JavaScript.

Рано или поздно с этим сталкивается любой разработчик, потому что нечаянно создать такое регулярное выражение – проще простого.

### Пример

Допустим, у нас есть строка, и мы хотим проверить, что она состоит из слов `\w+`, после каждого слова может быть пробел `\s?`.

Используем регулярное выражение `^(\w+\s?)*$`, которое задаёт `0` или более таких слов.

Проверим, чтобы убедиться, что оно работает:

~~~
const regexp = /^(\w+\s?)*$/;

console.log(regexp.test("A good string")); // true
console.log(regexp.test("Bad characters: $@#")); // false
~~~

Результат верный. Однако, на некоторых строках оно выполняется очень долго. Так долго, что интерпретатор JavaScript «зависает» с потреблением 100% процессора.

Если вы запустите пример ниже, то, скорее всего, ничего не увидите, так как JavaScript «подвиснет». В браузере он перестанет реагировать на другие события и, скорее всего, понадобится перезагрузить страницу:

~~~
const regexp = /^(\w+\s?)*$/;
const str = "An input string that takes a long time or even makes this regexp to hang!";

// этот поиск будет выполняться очень, очень долго
console.log(regexp.test(str));
~~~

Дело в том, что каждое слово может быть представлено как в виде одного `\w+`, так и нескольких:

~~~
(input)
(inpu)(t)
(inp)(u)(t)
(in)(p)(ut)
...
~~~

Человеку очевидно, что совпадения быть не может, так как эта строка заканчивается на восклицательный знак `!`, а по регулярному выражению в конце должен быть символ `\w` или пробел `\s`. Но движок этого не знает.

Он перебирает все комбинации того, как регулярное выражение `(\w+\s?)*` может «захватить» каждое слово, включая варианты как с пробелами `(\w+\s)*`, так и без `(\w+)*` (пробелы `\s?` ведь не обязательны). Этих вариантов очень много, отсюда и сверхдолгое время выполнения.

### Как исправить?

Есть два основных подхода, как это исправить.

1. Уменьшение возможных комбинаций переписыванием шаблона.

Перепишем регулярное выражение так: `^(\w+\s)*\w*` – то есть, будем искать любое количество слов с пробелом `(\w+\s)*`, после которых идёт (но не обязательно) обычное слово `\w*`.

Это регулярное выражение эквивалентно предыдущему (ищет то же самое), и на этот раз всё работает:

~~~
const regexp = /^(\w+\s)*\w*$/;
const str = "An input string that takes a long time or even makes this regex to hang!";

console.log(regexp.test(str)); // false
~~~

Почему же проблема исчезла?

Теперь звёздочка `*` стоит после `\w+\s` вместо `\w+\s?`. Стало невозможно разбить одно слово на несколько разных `\w+`. Исчезли и потери времени на перебор таких комбинаций.

Предыдущий шаблон из-за необязательности `\s` допускал варианты `\w+`, `\w+\s`, `\w+\w+` и т.п.

С переписанным шаблоном `(\w+\s)*`, такое невозможно: может быть `\w+\s` или `\w+\s\w+\s`, но не `\w+\w+`. Так что общее количество комбинаций сильно уменьшается.

2. Запрет возврата.

Если говорить об изначальном примере `^(\w+\s?)*$`, то хорошо бы исключить возврат для `\w+`. То есть, для `\w+` нужно искать только одно слово целиком, максимально возможной длины. Не нужно уменьшать количество повторений `\w+`, пробовать разбить слово на два `\w+\w+`, и т.п.

Мы можем исключить возврат с помощью опережающей проверки.

Шаблон, захватывающий максимальное количество повторений `\w` без возврата, выглядит так: `(?=(\w+))\1`.

Расшифруем его:

* Опережающая проверка `?=` ищет максимальное количество `\w+`, доступных с текущей позиции.
* Содержимое скобок вокруг `?=...` не запоминается движком, поэтому оборачиваем `\w+` внутри в дополнительные скобки, чтобы движок регулярных выражений запомнил их содержимое.
* ...И чтобы далее в шаблоне на него сослаться обратной ссылкой `\1`.

То есть, мы смотрим вперед – и если там есть слово `\w+`, то ищем его же `\1`.

Зачем? Всё дело в том, что опережающая проверка находит слово `\w+` целиком, и мы захватываем его в шаблон посредством `\1`. Поэтому мы реализовали, по сути, захватывающий квантификатор `+`. Такой шаблон захватывает только полностью слово `\w+`, не его часть.

Перепишем исходный пример, используя опережающую проверку для запрета возврата:

~~~
const regexp = /^((?=(\w+))\2\s?)*$/;

console.log(regexp.test("A good string")); // true

const str = "An input string that takes a long time or even makes this regex to hang!";

console.log(regexp.test(str)); // false, работает и быстро
~~~

Здесь внутри скобок стоит `\2` вместо `\1`, так как есть ещё внешние скобки. Чтобы избежать путаницы с номерами скобок, можно дать скобкам имя, например `(?<word>\w+)`.

~~~
// скобки названы ?<word>, ссылка на них \k<word>
const regexp = /^((?=(?<word>\w+))\k<word>\s?)*$/;

const str = "An input string that takes a long time or even makes this regex to hang!";

console.log(regexp.test(str)); // false

console.log(regexp.test("A correct string")); // true
~~~
