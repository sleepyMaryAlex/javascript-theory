# ?Greedy and lazy quantifiers

Допустим, нам нужно найти строки с кавычками.

Регулярное выражение вроде `/".+"/g` (кавычка, какой-то текст, другая кавычка) может выглядеть хорошим решением, но это не так!

~~~
const regexp = /".+"/g;

const str = 'a "witch" and her "broom" is one';

console.log(str.match(regexp)); // ['"witch" and her "broom"']
~~~

...Как мы видим, регулярное выражение работает не как задумано!

Вместо того, чтобы найти два совпадения `"witch"` и `"broom"`, было найдено одно: `"witch" and her "broom"`.

### Жадный поиск

Чтобы найти совпадение, движок регулярных выражений работает по следующему алгоритму:

* Для каждой позиции в строке для поиска:
  1. Попробовать найти совпадение с шаблоном на этой позиции.
  2. Если нет совпадения, переход к следующей позиции.

Эти общие слова никак не объясняют, почему регулярное выражение работает неправильно, так что давайте разберём подробно, как работает шаблон `".+"`.

1. Первый символ шаблона – это кавычка `"`.
2. Кавычка замечена, после чего движок пытается найти совпадение для оставшегося шаблона. Смотрит, удовлетворяет ли остаток строки шаблону `.+"`. В нашем случае следующий символ шаблона: `.` (точка). Она обозначает «любой символ, кроме новой строки».
3. Точке соответствуют любые символы, так что движок остановится только тогда, когда достигнет конца строки.
4. Тогда он перестанет повторять `.+` и попробует найти следующий символ шаблона. Это кавычка `"`. Но есть проблема: строка для поиска закончилась, больше нет символов! Движок регулярного выражения понимает, что захватил слишком много `.+` и начинает отступать. Другими словами, он сокращает совпадение по квантификатору на один символ.
5. Движок продолжает возвращаться: он уменьшает количество повторений `'.'`, пока оставшийся шаблон (в нашем случае `'"'`) не совпадёт.
6. Совпадение найдено.

##### В жадном режиме (по умолчанию) квантификатор повторяется столько раз, сколько это возможно.

Движок регулярного выражения пытается получить максимальное количество символов, соответствующих `.+`, а затем сокращает это количество символ за символом, если остаток шаблона не совпадает.

В нашей задаче мы хотим другого. И нам поможет ленивый режим квантификатора.

### Ленивый режим

«Ленивый» режим противоположен «жадному». Он означает: «повторять квантификатор наименьшее количество раз».

Мы можем включить его, вставив знак вопроса `'?'` после квантификатора, то есть будет `*?` или `+?` или даже `??` для `'?'`.

Проясним: обычно знак вопроса `?` сам по себе является квантификатором (ноль или один), но, если он добавлен после другого квантификатора (или даже после самого себя), он получает другое значение – он меняет режим совпадения с жадного на ленивый.

Регулярное выражение `/".+?"/g` работает как задумано, оно находит `"witch"` и `"broom"`:

~~~
const regexp = /".+?"/g;

const str = 'a "witch" and her "broom" is one';

console.log(str.match(regexp)); // ['"witch"', '"broom"']
~~~

Чтобы лучше понять, что поменялось, давайте рассмотрим процесс поиска шаг за шагом.

1. Движок находит начало шаблона `'"'` на 3-ей позиции.
2. Следующий шаг аналогичен: он найдёт совпадение для точки `'.'`.
3. Из-за того, что у нас включён ленивый режим для `+?`, движок не будет пытаться найти совпадение для точки ещё раз, оно остановится и попробует найти совпадение для оставшегося шаблона '"' прямо сейчас.
4. Находит совпадение.
5. Следующий поиск начнётся с того места, где закончилось текущее совпадение и у нас будет ещё один результат.

##### Ленивый режим включается только для квантификаторов с `?`.

### Альтернативный подход

С регулярными выражениями часто есть несколько путей добиться одного и того же результата.

В нашем случаем мы можем найти кавычки без использования ленивого режима с помощью регулярного выражения `"[^"]+"`:

~~~
const regexp = /"[^"]+"/g;

const str = 'a "witch" and her "broom" is one';

console.log(str.match(regexp)); // ['"witch"', '"broom"']
~~~

Регулярное выражение `"[^"]+"` получит нужный результат, потому что оно ищет кавычку `'"'`, за которой следует один или несколько символов «не-кавычек» `[^"]`, а затем – закрывающая кавычка.
