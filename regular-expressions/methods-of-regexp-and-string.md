# ?Methods of RegExp and String

### `str.match(regexp)`

Метод `str.match(regexp)` ищет совпадения с `regexp` в строке `str`.

У него есть три режима работы:

1. Если у регулярного выражения нет флага `g`, то он возвращает первое совпадение в виде массива со скобочными группами и свойствами `index` (позиция совпадения), `input` (строка поиска, равна `str`):

~~~
const str = "I love JavaScript";

const result = str.match(/Java(Script)/);

console.log(result[0]); // JavaScript (всё совпадение)
console.log(result[1]); // Script (первые скобки)
console.log(result.length); // 2

// Дополнительная информация:
console.log(result.index); // 7 (позиция совпадения)
console.log(result.input); // I love JavaScript (исходная строка)
~~~

2. Если у регулярного выражения есть флаг `g`, то он возвращает массив всех совпадений, без скобочных групп и других деталей.

~~~
const str = "I love JavaScript";

const result = str.match(/Java(Script)/g);

console.log(result[0]); // JavaScript
console.log(result.length); // 1
~~~

3. Если совпадений нет, то, вне зависимости от наличия флага `g`, возвращается `null`.

Это очень важный нюанс. При отсутствии совпадений возвращается не пустой массив, а именно `null`. Если об этом забыть, можно легко допустить ошибку, например:

~~~
const str = "I love JavaScript";

const result = str.match(/HTML/);

console.log(result); // null
console.log(result.length); // Ошибка: у null нет свойства length
~~~

Если хочется, чтобы результатом всегда был массив, можно написать так:

~~~
const result = str.match(/HTML/) || [];
~~~

### `str.matchAll(regexp)`

Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил.

Метод `str.matchAll(regexp)` – «новый, улучшенный» вариант метода `str.match`.

Он используется, в первую очередь, для поиска всех совпадений вместе со скобочными группами.

У него 3 отличия от `match`:

1. Он возвращает не массив, а перебираемый объект с результатами, обычный массив можно сделать при помощи `Array.from`.
2. Каждое совпадение возвращается в виде массива со скобочными группами (как `str.match` без флага `g`).
3. Если совпадений нет, то возвращается не `null`, а пустой перебираемый объект.

Пример использования:

~~~
const str = "<h1>Hello, world!</h1>";
const regexp = /<(.*?)>/g;

let matchAll = str.matchAll(regexp);

console.log(matchAll); // RegExpStringIterator (не массив, а перебираемый объект)

matchAll = Array.from(matchAll); // теперь массив

console.log(matchAll[0]); // ['<h1>', 'h1', index: 0, input: '<h1>Hello, world!</h1>', groups: undefined]
console.log(matchAll[1]); // ['</h1>', '/h1', index: 17, input: '<h1>Hello, world!</h1>', groups: undefined]
~~~

При переборе результатов `matchAll` в цикле `for..of` вызов `Array.from`, разумеется, не нужен.

### `str.split(regexp|substr, limit)`

Разбивает строку в массив по разделителю – регулярному выражению `regexp` или подстроке `substr`.

Обычно мы используем метод `split` со строками, вот так:

~~~
console.log("12, 34, 56".split(", ")); // [12, 34, 56]
~~~

Но мы можем разделить по регулярному выражению аналогичным образом:

~~~
console.log("12, 34, 56".split(/,\s*/)); // [12, 34, 56]
~~~

### `str.search(regexp)`

Метод `str.search(regexp)` возвращает позицию первого совпадения с `regexp` в строке `str` или `-1`, если совпадения нет.

~~~
const str = "Я люблю JavaScript!";

const regexp = /Java.+/;

console.log(str.search(regexp)); // 8
~~~

Важное ограничение: `str.search` умеет возвращать только позицию первого совпадения.

Если нужны позиции других совпадений, то следует использовать другой метод, например, найти их все при помощи `str.matchAll(regexp)`.

### `str.replace(str|regexp, str|func)`

Это универсальный метод поиска-и-замены, один из самых полезных. Этакий швейцарский армейский нож для поиска и замены в строке.

Мы можем использовать его и без регулярных выражений, для поиска-и-замены подстроки:

~~~
// заменить тире двоеточием
console.log("12-34-56".replace("-", ":")); // 12:34-56
~~~

Хотя есть подводный камень.

Когда первый аргумент `replace` является строкой, он заменяет только первое совпадение.

Вы можете видеть это в приведённом выше примере: только первый `"-"` заменяется на `":"`.

Чтобы найти все дефисы, нам нужно использовать не строку `"-"`, а регулярное выражение `/-/g` с обязательным флагом `g`:

~~~
// заменить все тире двоеточием
console.log("12-34-56".replace(/-/g, ":")); // 12:34:56
~~~

Второй аргумент – строка замены. Мы можем использовать специальные символы в нем:

| Спецсимволы	| Действие в строке замены |
|---|---|
| `$&` | вставляет всё найденное совпадение |
| `` $` `` | вставляет часть строки до совпадения |
| `$'` | вставляет часть строки после совпадения |
| `$n` | если `n` это 1-2 значное число, вставляет содержимое `n`-й скобочной группы регулярного выражения |
| `$<name>`	| вставляет содержимое скобочной группы с именем `name` |
| `$$` | вставляет символ `"$"` |

Например:

~~~
const str = "John Smith";

// поменять местами имя и фамилию
console.log(str.replace(/(\w+) (\w+)/i, "$2, $1")); // Smith, John
~~~

Для ситуаций, которые требуют «умных» замен, вторым аргументом может быть функция.

Она будет вызываться для каждого совпадения, и её результат будет вставлен в качестве замены.

Функция вызывается с аргументами `func(match, p1, p2, ..., pn, offset, input, groups)`:

* `match` – найденное совпадение.
* `p1, p2, ..., pn` – содержимое скобок.
* `offset` – позиция, на которой найдено совпадение.
* `input` – исходная строка.
* `groups` – объект с содержимым именованных скобок.

Если скобок в регулярном выражении нет, то будет только 3 аргумента: `func(match, offset, input)`.

Например, переведём выбранные совпадения в верхний регистр:

~~~
const str = "html and css";

const result = str.replace(/html|css/gi, (str) => str.toUpperCase());

console.log(result); // HTML and CSS
~~~

Заменим каждое совпадение на его позицию в строке:

~~~
console.log("Хо-Хо-хо".replace(/хо/gi, (match, offset) => offset)); // 0-3-6
~~~

В примере ниже две скобки, поэтому функция замены вызывается с 5-ю аргументами: первый – всё совпадение, затем два аргумента содержимое скобок, затем (в примере не используются) индекс совпадения и исходная строка:

~~~
const str = "John Smith";

const result = str.replace(
  /(\w+) (\w+)/,
  (match, name, surname) => `${surname}, ${name}`
);

console.log(result); // Smith, John
~~~

Если в регулярном выражении много скобочных групп, то бывает удобно использовать остаточные аргументы для обращения к ним:

~~~
const str = "John Smith";

const result = str.replace(
  /(\w+) (\w+)/,
  (...match) => `${match[2]}, ${match[1]}`
);

console.log(result); // Smith, John
~~~

Или, если мы используем именованные группы, то объект `groups` с ними всегда идёт последним, так что можно получить его так:

~~~
const str = "John Smith";

const result = str.replace(/(?<name>\w+) (?<surname>\w+)/, (...match) => {
  const groups = match.pop();

  return `${groups.surname}, ${groups.name}`;
});

console.log(result); // Smith, John
~~~

Использование функции даёт нам максимальные возможности по замене, потому что функция получает всю информацию о совпадении, имеет доступ к внешним переменным и может делать всё что угодно.

### `regexp.exec(str)`

Метод `regexp.exec(str)` ищет совпадение с `regexp` в строке `str`. В отличие от предыдущих методов, вызывается на регулярном выражении, а не на строке.

Он ведёт себя по-разному в зависимости от того, имеет ли регулярное выражение флаг `g`.

Если нет `g`, то `regexp.exec(str)` возвращает первое совпадение в точности как `str.match(regexp)`. Такое поведение не даёт нам ничего нового.

Но если есть `g`, то:

* Вызов `regexp.exec(str)` возвращает первое совпадение и запоминает позицию после него в свойстве `regexp.lastIndex`.
* Следующий такой вызов начинает поиск с позиции `regexp.lastIndex`, возвращает следующее совпадение и запоминает позицию после него в `regexp.lastIndex`.
* …И так далее.
* Если совпадений больше нет, то `regexp.exec` возвращает `null`, а для `regexp.lastIndex` устанавливается значение `0`.

Таким образом, повторные вызовы возвращают одно за другим все совпадения, используя свойство `regexp.lastIndex` для отслеживания текущей позиции поиска.

В прошлом, до появления метода `str.matchAll` в JavaScript, вызов `regexp.exec` использовали для получения всех совпадений с их позициями и группами скобок в цикле:

~~~
const str = "Больше о JavaScript на https://javascript.info";
const regexp = /javascript/gi;

let result;

while ((result = regexp.exec(str))) {
  console.log(`Найдено ${result[0]} на позиции ${result.index}`);
  // Найдено JavaScript на позиции 9, затем
  // Найдено javascript на позиции 31
}
~~~

Это работает и сейчас, хотя для современных браузеров `str.matchAll`, как правило, удобнее.

Мы можем использовать `regexp.exec` для поиска совпадения, начиная с нужной позиции, если вручную поставим `lastIndex`.

~~~
const str = "Hello, world!";

const regexp = /\w+/g; // без флага g свойство lastIndex игнорируется
regexp.lastIndex = 5; // ищем с 5-й позиции (т.е с запятой и далее)

console.log(regexp.exec(str)); // ['world', index: 7, input: 'Hello, world!', groups: undefined]
~~~

Если у регулярного выражения стоит флаг `y`, то поиск будет вестись не начиная с позиции `regexp.lastIndex`, а только на этой позиции (не далее в тексте).

В примере выше заменим флаг `g` на `y`. Ничего найдено не будет, поскольку именно на позиции `5` слова нет:

~~~
const str = "Hello, world!";

const regexp = /\w+/y;
regexp.lastIndex = 5; // ищем ровно на 5-й позиции

console.log(regexp.exec(str)); // null
~~~

Это удобно в тех ситуациях, когда мы хотим «прочитать» что-то из строки по регулярному выражению именно на конкретной позиции, а не где-то далее.

### `regexp.test(str)`

Метод `regexp.test(str)` ищет совпадение и возвращает `true`/`false`, в зависимости от того, находит ли он его.

~~~
const str = "Я люблю JavaScript";

// эти два теста делают одно и то же
console.log(/люблю/i.test(str)); // true
console.log(str.search(/люблю/i) != -1); // true
~~~

Пример с отрицательным ответом:

~~~
const str = "Go-go-go";

console.log(/люблю/i.test(str)); // false
console.log(str.search(/люблю/i) != -1); // false
~~~

Если регулярное выражение имеет флаг `g`, то `regexp.test` ищет, начиная с `regexp.lastIndex` и обновляет это свойство, аналогично `regexp.exec`.

Таким образом, мы можем использовать его для поиска с заданной позиции:

~~~
const regexp = /люблю/gi;

const str = "Я люблю JavaScript";

// начать поиск с 10-й позиции:
regexp.lastIndex = 10;
console.log(regexp.test(str)); // false (совпадений нет)
~~~

Одно и то же регулярное выражение, использованное повторно на другом тексте, может дать другой результат.

Если мы применяем одно и то же регулярное выражение последовательно к разным строкам, это может привести к неверному результату, поскольку вызов `regexp.test` обновляет свойство `regexp.lastIndex`, поэтому поиск в новой строке может начаться с ненулевой позиции.

Например, здесь мы дважды вызываем `regexp.test` для одного и того же текста, и второй раз поиск завершается уже неудачно:

~~~
const regexp = /javascript/g;

console.log(regexp.lastIndex); // 0
console.log(regexp.test("javascript")); // true
console.log(regexp.lastIndex); // 10
console.log(regexp.test("javascript")); // false
~~~

Это именно потому, что во втором тесте `regexp.lastIndex` не равен нулю.

Чтобы обойти это, можно присвоить `regexp.lastIndex = 0` перед новым поиском. Или вместо методов на регулярном выражении вызывать методы строк `str.match/search/...`, они не используют `lastIndex`.
