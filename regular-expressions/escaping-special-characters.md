# ?Escaping, special characters

Здесь речь пойдет об экранировании и специальных символах.

Допустим, мы хотим найти буквально точку. Не «любой символ», а именно точку.

Чтобы использовать специальный символ как обычный, добавьте к нему обратную косую черту: `\.`.

~~~
console.log("Глава 5.1".match(/\d\.\d/)); // ['5.1', index: 6, input: 'Глава 5.1', groups: undefined]
console.log("Глава 511".match(/\d\.\d/)); // null ("\." - ищет обычную точку)
~~~

Круглые скобки также являются специальными символами, поэтому, если нам нужно использовать именно их, нужно указать `\(`. В приведённом ниже примере ищется строка `"g()"`:

~~~
console.log("function g()".match(/g\(\)/)); // ['g()', index: 9, input: 'function g()', groups: undefined]
~~~

Если мы ищем обратную косую черту `\`, это специальный символ как в обычных строках, так и в регулярных выражениях, поэтому мы должны удвоить её.

~~~
console.log("1\\2".match(/\\/)); // ['\', index: 1, input: '1\2', groups: undefined]
~~~

Символ косой черты `'/'`, так называемый «слэш», не является специальным символом, но в JavaScript он используется для открытия и закрытия регулярного выражения: `/...шаблон.../`, поэтому мы должны экранировать его.

~~~
console.log("/".match(/\//)); // ['/', index: 0, input: '/', groups: undefined]
~~~

С другой стороны, если мы не используем короткую запись `/.../`, а создаём регулярное выражение, используя `new RegExp`, тогда нам не нужно экранировать косую черту:

~~~
console.log("/".match(new RegExp("/"))); // ['/', index: 0, input: '/', groups: undefined]
~~~

Если мы создаём регулярное выражение с помощью `new RegExp`, то нам не нужно учитывать `/`, но нужно другое экранирование.

Например, такой поиск не работает:

~~~
const regexp = new RegExp("\d\.\d");

console.log("Глава 5.1".match(regexp)); // null
~~~

Аналогичный поиск в примере выше с `/\d\.\d/` вполне работал, почему же не работает `new RegExp("\d\.\d")`?

Причина в том, что символы обратной косой черты «съедаются» строкой. Как вы помните, обычные строки имеют свои специальные символы, такие как `\n`, и для экранирования используется обратная косая черта.

Вот как воспринимается строка:

~~~
console.log("\d\.\d"); // d.d
~~~

Чтобы исправить это, нам нужно удвоить обратную косую черту, потому что строковые кавычки превращают `\\` в `\`:

~~~
const regStr = "\\d\\.\\d";
console.log(regStr); // \d\.\d (теперь правильно)

const regexp = new RegExp(regStr);

console.log("Глава 5.1".match(regexp)); // ['5.1', index: 6, input: 'Глава 5.1', groups: undefined]
~~~
