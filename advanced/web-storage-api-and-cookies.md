# ?Web Storage API & cookies

### Cookies

_Куки_ – это небольшие строки данных, которые хранятся непосредственно в браузере. Они являются частью HTTP-протокола.

Куки обычно устанавливаются веб-сервером при помощи заголовка `Set-Cookie`. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка `Cookie`.

Один из наиболее частых случаев использования куки – это аутентификация:

* При входе на сайт сервер отсылает в ответ HTTP-заголовок `Set-Cookie` для того, чтобы установить куки со специальным уникальным идентификатором сессии («session identifier»).
* Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
* Таким образом, сервер понимает, кто сделал запрос.

Мы также можем получить доступ к куки непосредственно из браузера, используя свойство `document.cookie`.

Хранит ли ваш браузер какие-то куки с этого сайта? Посмотрим:

~~~
console.log(document.cookie);
// _octo=GH1.1.540006208.1675672460; preferred_color_mode=light; tz=Europe%2FWarsaw
~~~

Значение `document.cookie` состоит из пар ключ=значение, разделённых `;`. Каждая пара представляет собой отдельное куки.

Мы можем писать в `document.cookie`. Но это не просто свойство данных, а акcессор (геттер/сеттер). Присваивание к нему обрабатывается особым образом.

Запись в `document.cookie` обновит только упомянутые в ней куки, но при этом не затронет все остальные.

~~~
document.cookie = "user=John"; // обновляем только куки с именем 'user'
console.log(document.cookie);
~~~

Технически, и имя и значение куки могут состоять из любых символов, для правильного форматирования следует использовать встроенную функцию `encodeURIComponent`:

~~~
const name = "my name";
const value = "John Smith"

document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);

console.log(document.cookie); // ...; my%20name=John%20Smith
~~~

Существует несколько ограничений:

* После `encodeURIComponent` пара name=value не должна занимать более 4Кб. Таким образом, мы не можем хранить в куки большие данные.
* Общее количество куки на один домен ограничивается примерно 20+. Точное ограничение зависит от конкретного браузера.

У куки есть ряд настроек, многие из которых важны и должны быть установлены.

Эти настройки указываются после пары ключ=значение и отделены друг от друга разделителем `;`, вот так:

~~~
document.cookie = "user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT"
~~~

##### path

`path=/mypath`

URL-префикс пути, куки будут доступны для страниц под этим путём. Должен быть абсолютным. По умолчанию используется текущий путь.

Если куки установлено с `path=/admin`, то оно будет доступно на страницах `/admin` и `/admin/something`, но не на страницах `/home` или `/adminpage`.

Как правило, указывают в качестве пути корень `path=/`, чтобы наше куки было доступно на всех страницах сайта.

##### domain

`domain=site.com`

Домен определяет, где доступен файл куки. Однако на практике существуют определённые ограничения. Мы не можем указать здесь какой угодно домен.

Нет никакого способа разрешить доступ к файлам куки из другого домена 2-го уровня, поэтому `other.com` никогда не получит куки, установленный по адресу `site.com`.

Это ограничение безопасности, позволяющее нам хранить конфиденциальные данные в файлах куки, которые должны быть доступны только на одном сайте.

По умолчанию куки доступны лишь тому домену, который его установил.

Пожалуйста, обратите внимание, что по умолчанию файл куки также не передаётся поддомену, например `forum.site.com`.

Но это можно изменить. Если мы хотим разрешить поддоменам типа `forum.site.com` получать куки, установленные на `site.com`, это возможно.

Чтобы это произошло, при установке файла куки в `site.com`, мы должны явно установить параметр domain для корневого домена: `domain=site.com`. После этого все поддомены увидят такой файл `cookie`.

##### expires, max-age

По умолчанию, если куки не имеют ни одного из этих параметров, то они удалятся при закрытии браузера. Такие куки называются сессионными («session cookies»).

Чтобы помочь куки «пережить» закрытие браузера, мы можем установить значение опций `expires` или `max-age`.

`expires=Tue, 19 Jan 2038 03:14:07 GMT`

Дата истечения срока действия куки, когда браузер удалит его автоматически.

Дата должна быть точно в этом формате, во временной зоне GMT. Мы можем использовать `date.toUTCString`, чтобы получить правильную дату. Например, мы можем установить срок действия куки на 1 день.

~~~
let date = new Date(Date.now() + 86400e3);
console.log(date); // Fri Apr 21 2023 19:03:04 GMT+0200 (Central European Summer Time)
date = date.toUTCString();
console.log(date); // Fri, 21 Apr 2023 17:03:04 GMT
document.cookie = "user=John; expires=" + date;
~~~

Если мы установим в `expires` прошедшую дату, то куки будет удалено.

`max-age=3600`

Альтернатива `expires`, определяет срок действия куки в секундах с текущего момента.

Если задан ноль или отрицательное значение, то куки будет удалено:

~~~
// куки будет удалено через 1 час
document.cookie = "user=John; max-age=3600";
~~~

##### secure

Куки следует передавать только по HTTPS-протоколу.

По умолчанию куки, установленные сайтом `http://site.com`, также будут доступны на сайте `https://site.com` и наоборот.

То есть, куки, по умолчанию, опираются на доменное имя, они не обращают внимания на протоколы.

С этой настройкой, если куки будет установлено на сайте `https://site.com`, то оно не будет доступно на том же сайте с протоколом HTTP, как `http://site.com`. Таким образом, если в куки хранится конфиденциальная информация, которую не следует передавать по незашифрованному протоколу HTTP, то нужно установить этот флаг.

~~~
document.cookie = "user=John; secure";
~~~

##### samesite

Это ещё одна настройка безопасности, применяется для защиты от так называемой `XSRF`-атаки (межсайтовая подделка запроса).

Чтобы понять, как настройка работает и где может быть полезной, посмотрим на `XSRF`-атаки.

> Атака `XSRF`
> Представьте, вы авторизовались на сайте `bank.com`. То есть: у вас есть куки для аутентификации с этого сайта. Ваш браузер отправляет его на сайт `bank.com` с каждым запросом, чтобы сервер этого сайта узнавал вас и выполнял все конфиденциальные финансовые операции.
> Теперь, просматривая веб-страницу в другом окне, вы случайно переходите на сайт `evil.com`, который автоматически отправляет форму `<form action="https://bank.com/pay">` на сайт `bank.com` с заполненными полями, которые инициируют транзакцию на счёт хакера.
> Браузер посылает куки при каждом посещении `bank.com`, даже если форма была отправлена с `evil.com`. Таким образом, банк узнает вас и выполнит платёж.
> Такая атака называется межсайтовая подделка запроса (или Cross-Site Request Forgery, XSRF).

Параметр куки `samesite` предоставляет один из способов защиты от таких атак.

Если вы установите для атрибута `SameSite` значение `Strict`, ваш файл cookie будет отправляться только для внутрисайтовых запросов. Говоря языком пользователей, файл `cookie` будет отправлен только в том случае, если сайт для файла `cookie` совпадает с сайтом, который в данный момент отображается в адресной строке браузера. Однако при переходе по ссылке на ваш сайт, например, с другого сайта или по электронной почте от друга, при первом запросе файл `cookie` не будет отправлен. Если ваш пользователь переходит по ссылке на сайт, он в большинстве случаев хочет, чтобы файл cookie был отправлен, чтобы были применены пользовательские предпочтения.

Именно здесь и приходит на помощь `SameSite=Lax`, который разрешает доступ к навигации верхнего уровня. Это делает значение Lax хорошим выбором для файлов cookie, влияющих на отображение сайта, а значение `Strict` полезным для файлов `cookie`, связанных с действиями пользователя. Если у файлов `cookie` не задан атрибут `SameSite`, будет считаться, что `SameSite=Lax`;

> Ни `Strict`, ни `Lax` не закрывают полностью проблему с безопасностью.  Файлы `cookie` отправляются как часть запроса пользователя, и вы должны относиться к ним так же, как и к любому другому пользовательскому вводу. Это означает, что необходимо проверять и подтверждать вводимые данные. Никогда не используйте файлы `cookie` для безопасного хранения данных на стороне сервера.

Вы можете использовать значение `SameSite=None`, чтобы четко указать, что вы намеренно хотите, чтобы файл `cookie` был отправлен в стороннем контексте. Для `cookie` с `SameSite=None` также нужно указывать параметр `Secure`, что означает, что такой запрос должен приходить только по защищённому каналу.

##### httpOnly

Эта настройка запрещает любой доступ к куки из JavaScript. Мы не можем видеть такое куки или манипулировать им с помощью `document.cookie`.

Эта настройка используется в качестве меры предосторожности от определённых атак, когда хакер внедряет свой собственный JavaScript-код в страницу и ждёт, когда пользователь посетит её. Это вообще не должно быть возможным, хакер не должен быть в состоянии внедрить свой код на ваш сайт, но могут быть ошибки, которые позволят хакеру сделать это.

Обычно, если такое происходит, и пользователь заходит на страницу с JavaScript-кодом хакера, то этот код выполняется и получает доступ к `document.cookie`, и тем самым к куки пользователя, которые содержат аутентификационную информацию. Это плохо.

Но если куки имеет настройку `httpOnly`, то `document.cookie` не видит его, поэтому такое куки защищено.

#### Функции для работы с куки

Вот небольшой набор функций для работы с куки, более удобных, чем ручная модификация `document.cookie`.

Для этого существует множество библиотек, так что они, скорее, в демонстрационных целях. Но при этом полностью рабочие.

##### getCookie(name)

~~~
function getCookie(name) {
  const matches = document.cookie.match(new RegExp(
    "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
  ));
  return matches ? decodeURIComponent(matches[1]) : undefined;
}
~~~

> Обратите внимание, значение куки кодируется, поэтому `getCookie` использует встроенную функцию `decodeURIComponent` для декодирования.

##### setCookie(name, value, options)

~~~
function setCookie(name, value, options = {}) {
  options = {
    path: '/',
    // при необходимости добавьте другие значения по умолчанию
    ...options
  };

  if (options.expires instanceof Date) {
    options.expires = options.expires.toUTCString();
  }

  let updatedCookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);

  for (const optionKey in options) {
    updatedCookie += "; " + optionKey;
    const optionValue = options[optionKey];
    if (optionValue !== true) {
      updatedCookie += "=" + optionValue;
    }
  }

  document.cookie = updatedCookie;
}

setCookie('user', 'John', {secure: true, 'max-age': 3600});
~~~

##### deleteCookie(name)

Чтобы удалить куки, мы можем установить отрицательную дату истечения срока действия:

~~~
function deleteCookie(name) {
  setCookie(name, "", {
    'max-age': -1
  })
}
~~~

> Операции обновления или удаления куки должны использовать те же путь и домен.

#### Сторонние куки

Файлы `cookie`, соответствующие домену текущего сайта, то есть тому, что отображается в адресной строке браузера, называются основными файлами `cookie`. Аналогично, файлы `cookie` из доменов, отличных от текущего сайта, называются сторонними файлами `cookie`.

Именно этот механизм позволяет сайтам сохранять состояние, когда они используются в стороннем контексте. Например, если вы разместите на своем сайте видео с YouTube, посетители увидят в проигрывателе опцию «Посмотреть позже». Если ваш посетитель уже зарегистрирован на YouTube, его сессия будет доступна во встроенном проигрывателе с помощью стороннего cookie, то есть кнопка «Посмотреть позже» просто сохранит видео одним махом, а не предложит ему войти в систему или переместит его с вашей страницы обратно на YouTube.

> Сторонние куки могут быть запрещены браузером, например Safari делает это по умолчанию.
> Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия на это в соответствии с законодательством GDPR.

### Local Storage, Session Storage

Объекты веб-хранилища `localStorage` и `sessionStorage` позволяют хранить пары ключ/значение в браузере.

Что в них важно – данные, которые в них записаны, сохраняются после обновления страницы (в случае `sessionStorage`) и даже после перезапуска браузера (при использовании `localStorage`). Скоро мы это увидим.

Но ведь у нас уже есть куки. Зачем тогда эти объекты?

* В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе. Именно поэтому мы можем хранить гораздо больше данных. Большинство современных браузеров могут выделить как минимум 5 мегабайтов данных (или больше), и этот размер можно поменять в настройках.
* Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
* Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.

Объекты хранилища `localStorage` и `sessionStorage` предоставляют одинаковые методы и свойства:

* `setItem(key, value)` – сохранить пару ключ/значение.
* `getItem(key)` – получить данные по ключу `key`.
* `removeItem(key)` – удалить данные с ключом `key`.
* `clear()` – удалить всё.
* `key(index)` – получить ключ на заданной позиции.
* `length` – количество элементов в хранилище.

##### Local Storage

Основные особенности `localStorage`:

* Этот объект один на все вкладки и окна в рамках источника (один и тот же домен/протокол/порт).
* Данные не имеют срока давности, по которому истекают и удаляются. Сохраняются после перезапуска браузера и даже ОС.

Например, если запустить этот код…

~~~
localStorage.setItem('test', 1);
~~~

…И закрыть/открыть браузер или открыть ту же страницу в другом окне, то можно получить данные следующим образом:

~~~
console.log(localStorage.getItem('test')); // 1
~~~

Нам достаточно находиться на том же источнике (домен/протокол/порт), при этом URL-путь (та часть, которая идёт после первого слэша `/`) может быть разным.

Объект `localStorage` доступен всем окнам из одного источника, поэтому, если мы устанавливаем данные в одном окне, изменения становятся видимыми в другом.

Также можно получать/записывать данные, как в обычный объект:

~~~
localStorage.test = 2;

console.log(localStorage.test); // 2

delete localStorage.test;
~~~

Это возможно по историческим причинам и, как правило, работает, но обычно не рекомендуется, потому что:

* Если ключ генерируется пользователем, то он может быть каким угодно, включая `length` или `toString` или другой встроенный метод `localStorage`. В этом случае `getItem`/`setItem` сработают нормально, а вот чтение/запись как свойства объекта не пройдут:

~~~
localStorage.length = 5;

console.log(localStorage.getItem('length')); // null
console.log(localStorage.length); // 0, так как в local storage ничего нет
~~~

К сожалению, объекты веб-хранилища нельзя перебрать в цикле, они не итерируемы.

Но можно пройти по ним, как по обычным массивам. Один из способов:

~~~
localStorage.setItem("test", 5);
localStorage.setItem("lang", "en");

for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  console.log(`${key}: ${localStorage.getItem(key)}`);
}

// lang: en
// test: 5

PS: сортировка не совпадает с датой добавления свойства
~~~

Обратите внимание, что ключ и значение должны быть __строками__.

Если мы используем любой другой тип, например число или объект, то он автоматически преобразуется в строку:

~~~
localStorage.setItem("user", { name: "John" });

console.log(localStorage.getItem("user")); // [object Object]
~~~

Мы можем использовать JSON для хранения объектов:

~~~
localStorage.setItem("user", JSON.stringify({ name: "John" }));

console.log(JSON.parse(localStorage.getItem("user"))); // { name: 'John' }
~~~

Также возможно привести к строке весь объект хранилища, например для отладки:

~~~
localStorage.setItem("john", JSON.stringify({ name: "John" }));
localStorage.setItem("mary", JSON.stringify({ name: "Mary" }));

function replacer(key, value) {
  if (key === 'mary') {
    return undefined;
  }
  return value;
}

console.log(JSON.stringify(localStorage, replacer, 2));
// {
//  "john": "{\"name\":\"John\"}"
// }
~~~

Параметры `JSON.stringify`:

1. Значение для преобразования в строку JSON.
2. Необязательный. Используется когда какие-то конкретные ключи объектов Javascript должны быть включены в строку, а какие-то нет. Мы можем сделать это двумя способами: в виде функции, как в примере выше, или в виде массива:

~~~
console.log(JSON.stringify(localStorage, ['john'], 2));
// {
//  "john": "{\"name\":\"John\"}"
// }
~~~

Но это не единственный способ использования.

Метод `JSON.stringify` не включает функции или значения символов в свою окончательную строку, мы можем сначала преобразовать их в строку, а затем передать их функции строковой обработки JSON, чтобы они также были включены. Например:

~~~
function sum(a, b) {
  return a + b;
}

function replacer(key, value) {
  if (typeof value === "function") {
    return value.toString();
  }
  return value;
}

localStorage.setItem("func", JSON.stringify({ func: sum }, replacer));
console.log(localStorage.getItem("func")); // {"func":"function sum(a,b) {\r\n  return a + b\r\n}"}
// без replacer было бы так: {}
~~~

Если `replacer` это что-либо, кроме функции или массива (например `null`), все строковые свойства объекта включаются в результирующую строку JSON.

3. Необязательный. Строка или число, которое используется для вставки пробелов (включая отступы, символы разрыва строки и т. д.) в выходную строку JSON для удобства чтения.

###### Событие storage

Когда обновляются данные в `localStorage`, генерируется событие `storage` со следующими свойствами:

* `key` – ключ, который обновился (`null`, если вызван `.clear()`).
* `oldValue` – старое значение (`null`, если ключ добавлен впервые).
* `newValue` – новое значение (`null`, если ключ был удалён).
* `url` – url документа, где произошло обновление.
* `storageArea` – объект, где произошло обновление.

Важно: событие срабатывает на всех остальных окнах, где доступно хранилище, кроме того окна, которое его вызвало.

~~~
window.addEventListener('storage', event => {
  if (event.key != 'now') return;
  console.log(event.key + ': ' + event.newValue);
});

localStorage.setItem('now', Date.now()); // now: 1681987102641
~~~

##### Session Storage

Объект `sessionStorage` используется гораздо реже, чем `localStorage`.

Свойства и методы такие же, но есть существенные ограничения:

* `sessionStorage` существует только в рамках текущей вкладки браузера.
  * Другая вкладка с той же страницей будет иметь другое хранилище.
  * Но хранилище будет общим для ифреймов на той же вкладке (при условии, что они из одного и того же источника).
* Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.
