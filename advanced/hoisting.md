# ? Hoisting

_Поднятие (hoisting)_ – это поведение JavaScript по умолчанию, когда любое объявление переменной или функции поднимается вверх в ее области видимости. Другими словами, переменная или функция может быть использована до ее объявления.

Это связано с работой компилятора JavaScript. Компиляция кода происходит в два этапа. При первом этапе компилятор получает все объявления переменных и функций. На втором этапе происходит выполнение кода. И даже если переменная или функция определена после непосредственного использования, ошибки не возникнет, так как компилятору уже известны все переменные и функции.

JavaScript "поднимает" только объявление, но не инициализацию. Например, если переменная объявлена и инициализирована после её использования, значение будет `undefined`:

~~~
console.log(foo); // undefined
var foo = "Tom";
~~~

ES6 (ECMAScript 6) представил два новых способа объявления переменных: `const` и `let`, и, как правило, они рекомендуются во избежание неожиданных осложнений с поднятием.

~~~
console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
const foo = "Tom";
~~~

Переменные без ключевого слова не "поднимаются":

~~~
console.log(hoist); // Вывод: ReferenceError: hoist is not defined
hoist = 'Hoisted';
~~~

Все то же самое относится и к использованию функций. Мы можем сначала вызвать функцию, а потом уже ее определить:

~~~
display();
function display() {
  console.log("Hello Hoisting"); // Hello Hoisting
}
~~~

__Temporal dead zone__

_TDZ (временная мертвая зона)_ - состояние, когда переменные находятся в области видимости, но недоступны.
Переменные `let` и `const` существуют в TDZ с начала их области видимости до момента их объявления. Компилятор знает о них, но не позволяет получить доступ. Если бы мы обратились к переменной c `let` или `const` в блоке раньше, чем она была объявлена, это вызвало бы ошибку ReferenceError из-за TDZ. Но `var` этого не сделает. `var` просто инициализируется по умолчанию в `undefined`.
Пытаться получить доступ к переменной до ее объявления – это неправильный путь, и он не должен быть возможным. Поэтому у нас есть TDZ.

Этот фрагмент кода не вызовет ошибку, поскольку `return name` выполнится только тогда, когда name выйдет из TDZ.

~~~
function readName() {
  return name;
}

const name = 'Tom';

console.log(readName()); // Tom
~~~
