# ?Basic sorting and searching algorithms

Метод массива `sort()` по умолчанию сортирует в лексическом порядке по возрастанию. Т.е. перед сравнением значения будут переведены в строку. Чтобы добиться желаемого результата, нужно написать функцию-аргумент, в которой и указать способ сравнения. 
Для того, чтобы сортировка прошла по числам в возрастающем порядке, функция-параметр должна быть такой:

~~~
function sortFunction(a, b) {
  return (a — b);
}
~~~

Это работает так, как и должно работать, так как всякий раз когда `a` меньше, чем `b`, возвращается негативное значение, что ведет к тому, что меньший элемент всегда будет выставляться левее большего, а другими словами, порядок будет выстроен по возрастанию. 

Итак, функция сравнения имеет следующую форму:

~~~
function compare(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
~~~

__Эффективность алгоритмов сортировки__

Некоторые алгоритмы сортировки более эффективны, чем другие. Эффективность алгоритма сортировки обычно определяется следующими показателями производительности:

* Временная сложность : это количество времени, необходимое компьютеру для выполнения сортировки на основе алгоритма.

* Сложность памяти : это объем компьютерной памяти, необходимый компьютеру для выполнения сортировки на основе алгоритма.

JavaScript по умолчанию использует сортировку вставками для sort() метода. Это означает, что он не подходит для сортировки больших наборов данных. При работе с большими наборами данных следует учитывать другие алгоритмы сортировки, такие как сортировка слиянием.

### Пузырьковая сортировка (bubble sort)

Обходим массив от начала до конца, попутно меняя местами неотсортированные соседние элементы. В результате первого прохода на последнее место «всплывёт» максимальный элемент. Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего) и меняем по пути неотсортированных соседей. Второй по величине элемент окажется на предпоследнем месте. Продолжая в том же духе, будем обходить всё уменьшающуюся неотсортированную часть массива, запихивая найденные максимумы в конец.

~~~
function bubbleSort(arr) {
  let right = arr.length - 1;
  while (right > 0) {
    for (let i = 0; i < right; i++) {
      if (arr[i + 1] < arr[i]) {
        [arr[i + 1], arr[i]] = [arr[i], arr[i + 1]];
      }
    }
    right--;
  }
  return arr;
}

console.log(bubbleSort([5, 3, 8, 4, 6]));
~~~

### Шейкерная сортировка (cocktail sort)

Она же сортировка перемешиванием, она же коктейльная сортировка. Начинается процесс как в «пузырьке»: выдавливаем максимум на самые задворки. После этого разворачиваемся на 1800 и идём в обратную сторону, при этом уже перекатывая в начало не максимум, а минимум. Отсортировав в массиве первый и последний элементы, снова делаем кульбит. Обойдя туда-обратно несколько раз, в итоге заканчиваем процесс, оказавшись в середине списка. Шейкерная сортировка работает немного быстрее чем пузырьковая, поскольку по массиву в нужных направлениях попеременно мигрируют и максимумы и минимумы. Улучшения, как говорится, налицо.

~~~
function cocktailSort(arr) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    for (let i = left; i < right; i++) {
      if (arr[i] > arr[i + 1]) {
        [arr[i + 1], arr[i]] = [arr[i], arr[i + 1]];
      }
    }
    right--;
    for (let i = right; i > left; i--) {
      if (arr[i] < arr[i - 1]) {
        [arr[i], arr[i - 1]] = [arr[i - 1], arr[i]];
      }
    }
    left++;
  }
  return arr;
}

console.log(cocktailSort([5, 3, 8, 4, 6]));
~~~

### Чётно-нечётная сортировка (odd-even sort)

На сей раз мы не будем сновать по массиву взад-вперёд, а снова вернёмся к идее планомерного обхода слева-направо, но только сделаем шире шаг. На первом проходе элементы с нечётным ключом сравниваем с соседями, зиждущимися на чётных местах (1-й сравниваем со 2-м, затем 3-й с 4-м, 5-й с 6-м и так далее). Затем наоборот – «чётные по счёту» элементы сравниваем/меняем с «нечётными». Затем снова «нечёт-чёт», потом опять «чёт-нечет». Процесс останавливается тогда, когда после подряд двух проходов по массиву («нечётно-чётному» и «чётно-нечётному») не произошло ни одного обмена. Стало быть, отсортировали.

~~~
function oddEvenSort(arr) {
  let isSorted = false;
  while (!isSorted) {
    isSorted = true;
    for (let i = 1; i < arr.length - 1; i = i + 2) {
      if (arr[i] > arr[i + 1]) {
        [arr[i + 1], arr[i]] = [arr[i], arr[i + 1]];
        isSorted = false;
      }
    }
    for (let i = 0; i < arr.length - 1; i = i + 2) {
      if (arr[i] > arr[i + 1]) {
        [arr[i + 1], arr[i]] = [arr[i], arr[i + 1]];
        isSorted = false;
      }
    }
  }
  return arr;
}

console.log(oddEvenSort([34, 2, 10, -9]));
~~~

### Сортировка расчёской (comb sort)

В «пузырьке», «шейкере» и «чёт-нечете» при переборе массива сравниваются соседние элементы. Основная идея «расчёски» в том, чтобы первоначально брать достаточно большое расстояние между сравниваемыми элементами и по мере упорядочивания массива сужать это расстояние вплоть до минимального. Таким образом мы как бы причёсываем массив, постепенно разглаживая на всё более аккуратные пряди.

~~~
function combSort(arr) {
  let gap = arr.length;
  let swapped = true;

  while (gap != 1 || swapped == true) {
    gap = parseInt((gap * 10) / 13);
    gap = gap < 1 ? 1 : gap;
    swapped = false;

    for (let i = 0; i < arr.length - gap; i++) {
      if (arr[i] > arr[i + gap]) {
        [arr[i + gap], arr[i]] = [arr[i], arr[i + gap]];
        swapped = true;
      }
    }
  }
  return arr;
}

console.log(combSort([8, 4, 1, 56, -7]));
~~~

### Сортировка выбором (selection sort)

Алгоритм многократно выбирает наименьший (или наибольший) элемент из несортированной части списка и меняет его местами с первым элементом несортированной части. Этот процесс повторяется для оставшейся несортированной части списка, пока весь список не будет отсортирован. Один вариант сортировки выбором называется «двунаправленная сортировка выбора», которая проходит через список элементов, чередуя наименьший и наибольший элемент, таким образом, алгоритм может быть быстрее в некоторых случаях.
После каждой итерации размер отсортированного подмассива увеличивается на единицу, а размер несортированного подмассива уменьшается на единицу.

~~~
function selectionSort(arr) {
  let minIndex;

  for (let i = 0; i < arr.length - 1; i++) {
    minIndex = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];
  }
  return arr;
}

console.log(selectionSort([64, 25, 12, 22, 11]));
~~~

### Сортировка вставками (insertion sort)

Алгоритм предполагает проход по всему массиву с тем, чтобы длина отсортированной части стала равна длине всего массива. В рамках каждой итерации мы берем первый элемент неотсортированной части массива и осуществляем с ним следующую операцию: пока наш элемент строго меньше чем предыдущий меняем их местами. После чего увеличиваем длину отсортированной части массива на единицу. Таким образом путем последовательного перемещения изучаемого элемента мы добиваемся того, чтобы он встал на свое место.

~~~
function insertionSort(arr) {
  let j, key;
  for (let i = 1; i < arr.length; i++) {
    key = arr[i];
    j = i - 1;

    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j = j - 1;
    }
   
    arr[j + 1] = key;
  }
  return arr;
}

console.log(insertionSort([64, 12, 25, 22, 11]));
~~~

### Сортировка слиянием (merge sort)

Ее алгоритм можно условно разделить на две составляющих:
1. Разбиение входного массива данных на более мелкие, затем снова их дробление и так до тех пор, пока не останутся части из одного элемента;
2. Слияние в правильном порядке (по умолчанию мы рассматриваем сортировку по возрастанию) всех мелких частей снова в более и более крупные и получение в итоге единого отсортированного массива.

~~~
function merge(arrFirst, arrSecond) {
  const arrSort = [];
  let i = (j = 0);

  while (i < arrFirst.length && j < arrSecond.length) {
    arrSort.push(arrFirst[i] < arrSecond[j] ? arrFirst[i++] : arrSecond[j++]);
  }

  return [...arrSort, ...arrFirst.slice(i), ...arrSecond.slice(j)];
}

function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const middle = Math.floor(arr.length / 2);
  const arrLeft = arr.slice(0, middle);
  const arrRight = arr.slice(middle);

  return merge(mergeSort(arrLeft), mergeSort(arrRight));
}

console.log(mergeSort([64, 12, 25, 22, 11]));
~~~

### Быстрая сортировка (quick sort)

Первое что нужно сделать – это выбрать одно значение и сделать его опорным значением, например, последнее в массиве. Следующее, что вы должны сделать – поместить значения, которые меньше или равны опорному значению с левой стороны. Значения больше опорного будут располагаться справа. Теперь вы будете повторять тот же процесс для каждого подмассива, пока не останется только одно значение или пустой список значений. Следующий шаг – начать со списков отдельных значений. Затем поместить значение слева от опорного значения, если оно уже находится слева, или поместите его справа, если оно уже находится справа.

~~~
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const pivot = arr[arr.length - 1];
  const arrLeft = [];
  const arrRight = [];

  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] < pivot) {
      arrLeft.push(arr[i]);
    } else {
      arrRight.push(arr[i]);
    }
  }

  return [...quickSort(arrLeft), pivot, ...quickSort(arrRight)];
}

console.log(quickSort([2, 27, 14, 52, 20]));
~~~
