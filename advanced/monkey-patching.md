# ?Monkey patching

_Monkey patching_ — это метод добавления, изменения или подавления поведения фрагмента кода по умолчанию во время выполнения без изменения исходного кода.

В прошлом он широко использовался библиотеками, такими как `MooTools`, и разработчиками для добавления методов, отсутствующих в JavaScript. Известным примером является метод `endWith()`, который был представлен в ECMAScript 2015. До этой версии разработчикам приходилось самим реализовывать этот метод. Есть несколько способов сделать это.

Один из возможных подходов — создать объект `Utility`, который предоставляет метод `endWith()`, как показано ниже:

~~~
const Utility = {
  endsWith: function (string, suffix) {
    return string.indexOf(suffix, string.length - suffix.length) !== -1;
  },
};

const isSuffix = Utility.endsWith('hello world', 'ld');
console.log(isSuffix); // true
~~~

Другой подход заключается в том, чтобы добавить метод во встроенный объект `String`:

~~~
String.prototype.endsWith = function (suffix) {
  return this.indexOf(suffix, this.length - suffix.length) !== -1;
};

const isSuffix = "hello world".endsWith("ld");
console.log(isSuffix); // true
~~~

На первый взгляд, вторая версия имеет больше смысла, потому что `endsWith()` логически принадлежит строке. Однако, как мы обсудим позже, этот подход может вызвать несколько проблем.

В примере `endWith()` показано, как использовать monkey patching для добавления метода к встроенному объекту, но monkey patching также можно использовать для изменения поведения метода.

### Использование monkey patching для изменения метода

Многие разработчики склонны использовать `console.log()` при отладке своего кода. Этот метод не должен использоваться профессиональными разработчиками, так как они должны использовать точки останова и следить за переменными.

Ради этого обсуждения давайте представим, что `console.log()` это лучший способ отладки кода и что вы используете его для проверки значения переменной в разные моменты времени. Все работает хорошо, но вы понимаете, что было бы неплохо, если бы помимо вывода значения переменной метод печатал дату вызова метода. Для достижения этой цели вы можете использовать monkey patching следующим образом:

~~~
// Save the original console.log() method
const log = console.log;
console.log = function () {
  // Invoke the original method with an additional parameter
  log.apply(console, [new Date().toString()].concat(arguments));
};

console.log("Hi");
// Sun Jun 18 2023 19:59:41 GMT+0200 (Central European Summer Time) Arguments(1) ['Hi', callee: <accessor>, Symbol(Symbol.iterator): ƒ]
~~~

В этом коде мы сначала сохраняем исходный метод `console.log()` в переменной с именем `log`. Это позволяет нам повторно использовать исходный метод всякий раз, когда мы захотим. Затем мы назначаем анонимную функцию `log` свойству `console`. Другими словами, мы переопределяем исходный метод `console.log()`. Внутри анонимной функции мы вызываем исходный метод `console.log()`, хранящийся в переменной `log`, передавая ему все аргументы, переданные анонимной функции (через использование `arguments`), с добавлением текущей даты и времени.

Теперь, когда мы обсудили, что такое monkey patching и как его использовать, давайте рассмотрим, почему это обычно считается плохой практикой и когда это может быть полезно.

### Минусы monkey patching

Monkey patching часто считается опасным методом. Не так давно использование monkey patching привело к переименованию метода `String.prototype.contains()` ECMAScript 2015 года в `String.prototype.includes()`. Это изменение было необходимо, чтобы избежать поломки веб-сайтов, использующих `MooTools`, который добавляет метод `contains()` в `String.prototype`, из-за введения версии метода ECMAScript. В частности, проблема заключалась в том, что метод `contains()`, добавленный `MooTools`, и метод `contains()`, добавленный в ECMAScript 2015, были несовместимы.

Урок, который следует здесь усвоить, заключается в том, что monkey patching, особенно когда оно используется для встроенных объектов, может помешать развитию языка. Это правило также можно распространить на любой код, которым вы не владеете, например на библиотеку или фреймворк.

Еще один момент, о котором следует помнить, когда Monkey исправляет код, которым вы не владеете, заключается в том, что вы никогда не можете быть уверены в поведении методов, которые вы исправляете. Фактически, точно так же, как вы изменили метод, другой разработчик в другой части программного обеспечения мог бы сделать то же самое. Таким образом, есть вероятность, что две версии будут конфликтовать, вызывая проблемы в программном обеспечении.

### Когда использовать monkey patching

Есть один и только один способ безопасного monkey patching - использовать уникальные символы:

~~~
const remove = Symbol("remove");

Array.prototype[remove] = function (value) {
  const index = this.indexOf(value);

  if (index !== -1) {
    this.splice(index, 1);
  }

  return this;
};

console.log([1, 2, 3, 4, 5][remove](2)[remove](4)); // [1, 3, 5]
~~~

Это прекрасно работает и не будет загрязнять какие-либо глобальные пространства имен.

Также, один из случаев, когда monkey patching является хорошим выбором, — это когда оно используется для методов полифилла, которые уже являются частью стандарта ECMAScript и не поддерживаются каждым браузером. Это безопасный выбор, поскольку метод уже стандартизирован, поэтому вы знаете его сигнатуру и точное поведение.

Кроме того, используя защитный метод, вы можете быть уверены, что добавляете собственную версию только в том случае, если встроенная версия недоступна. Чтобы понять, как можно безопасно использовать monkey patching, давайте рассмотрим пример.

Как упоминалось ранее, одним из методов, представленных в ECMAScript 2015, является `String.prototype.includes()`. Он возвращает `true` если одна строка содержится внутри другой; `false` в противном случае:

~~~
String.prototype.includes(searchString[, position])
~~~

`searchString` - это строка для поиска, `position` - необязательный параметр для указания позиции, с которой нужно начать поиск `searchString`. Значение `position` по умолчанию равно `0`.

Для поддержки браузеров, которые не раскрывают метод `String.prototype.includes()`, мы можем использовать monkey patching. Чтобы не переопределить нативную реализацию `String.prototype.includes()` в браузерах, которые изначально поддерживают этот метод, мы должны добавить функцию только в том случае, если она не существует в браузере.

Этого можно достичь двумя эквивалентными способами.

Первое решение — использовать `if`:

~~~
if (!String.prototype.includes) {
  String.prototype.includes = function (search, start) {
    "use strict";

    if (search instanceof RegExp) {
      throw TypeError("first argument must not be a RegExp");
    }

    if (start === undefined) {
      start = 0;
    }
    return this.indexOf(search, start) !== -1;
  };
}
~~~

Другой подход заключается в использовании логического оператора `||` (ИЛИ):

~~~
String.prototype.includes =
  String.prototype.includes ||
  function (search, start) {
    "use strict";

    if (search instanceof RegExp) {
      throw TypeError("first argument must not be a RegExp");
    }

    if (start === undefined) {
      start = 0;
    }
    return this.indexOf(search, start) !== -1;
  };
~~~
