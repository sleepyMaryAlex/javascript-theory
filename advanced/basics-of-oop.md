# ?Basics of OOP
_Объектно-ориентированное программирование_ — это стиль программирования, основанный на классах и объектах.

Что такое класс?
Вы можете думать о классе как о чертеже дома. Класс не является объектом реального мира, но мы можем создавать объекты из класса. Это как шаблон для объекта.

__В ООП есть 4 основных принципа, а именно:__

1. Инкапсуляция
2. Абстракция
3. Наследование
4. Полиморфизм

### Инкапсуляция

_Инкапсуляция_ — концепция ООП, и она означает способность объекта «решать», какую информацию он предоставляет «внешнему», а какую нет. Инкапсуляция реализуется через общедоступные и частные свойства и методы .

В JavaScript все свойства и методы объектов по умолчанию общедоступны. «Общедоступный» просто означает, что мы можем получить доступ к свойству/методу объекта из-за пределов его собственного тела. 

Допустим, мы не хотим, чтобы какое-то свойство было доступно откуда-либо еще, кроме самого объекта. 

```#birthYear```

Теперь, если мы попытаемся получить доступ к свойству напрямую, мы получим ошибку.
Инкапсуляция полезна в тех случаях, когда нам нужны определенные свойства или методы для внутренней работы объекта, но мы не хотим раскрывать их снаружи.

### Абстракция

_Абстракция_ означает сокрытие определенных деталей, которые не имеют значения для пользователя, и отображение только основных функций или функций.

Например, взять сотовый телефон. Мы не показываем такие детали verifyTemperature(), как verifyVolt(), frontCamOn(), frontCamOff() и так далее. Вместо этого мы предоставляем важные функции, которые важны для пользователя, такие как camera(), volumeBtn() и другие.

Этот принцип тесно связан с инкапсуляцией, поскольку мы можем использовать общедоступные и частные свойства/методы, чтобы решить, что будет раскрыто, а что нет.

### Наследование

_Наследование_ — это возможность создавать классы на основе других классов. С помощью наследования мы можем определить родительский класс (с определенными свойствами и методами), а затем дочерние классы , которые будут наследовать от родительского класса все свойства и методы, которые у него есть.
В дочернем классе мы используем extends ключевое слово для объявления родительского класса, от которого мы хотим наследоваться. Затем в методе конструктора мы должны объявить параметр и использовать super чтобы указать, что свойство объявлено в родительском классе. 

__У классов есть ключевое слово "super" для таких случаев.__

* super.method(...) вызывает родительский метод.
* super(...) для вызова родительского конструктора (работает только внутри нашего конструктора).

~~~
class Enemy {
  constructor(power) {
    this.power = power;
  }
  attack() {
    return `I'm attacking with a power of ${this.power}!`;
  }
}

class Alien extends Enemy {
  constructor(name, power) {
    super(power);
    this.name = name;
  }
}
const alien1 = new Alien("Ali", 10);

console.log(alien1.attack()); // output: I'm attacking with a power of 10!
~~~

* Класс может иметь только один родительский класс для наследования. Вы не можете расширить несколько классов, хотя есть хаки и способы обойти это.
* Вы можете расширять цепочку наследования настолько, насколько хотите, устанавливая родительские, прародительские, прапрародительские классы и так далее.
* Если дочерний класс наследует какие-либо свойства от родительского класса, он должен сначала присвоить родительские свойства при помощи super()прежде чем присваивать свои собственные свойства.
* При наследовании все родительские методы и свойства будут наследоваться потомками. Мы не можем решить, что унаследовать от родительского класса.
* Дочерние классы могут переопределять свойства и методы родителя (то есть могут полностью или частично менять).

~~~
class Enemy {
  constructor(power) {
    this.power = power;
  }
  attack() {
    return `I'm attacking with a power of ${this.power}!`;
  }
}

class Alien extends Enemy {
  constructor(name, power) {
    super(power);
    this.name = name;
  }
  attack() {
    return `${super.attack()} HA!`;
  }
}
const alien1 = new Alien("Ali", 10);

console.log(alien1.attack()); // output: I'm attacking with a power of 10! HA!
~~~

### Полиморфизм

_Полиморфизм_ означает «множество форм» и на самом деле является простой концепцией. Это способность одного метода возвращать разные значения в зависимости от определенных условий.
Например, мы видели, что у класса Enemy есть sayPhrase метод. И все наши классы видов наследуются от класса Enemy, что означает, что все они sayPhrase также имеют метод. Но, когда мы вызываем метод для разных видов, мы получаем разные результаты, потому что мы передавали каждому классу отдельный параметр при создании экземпляра. Или, у нас есть родительский класс, который устанавливает метод, а дочерний класс переопределяет этот метод, чтобы каким-то образом изменить его. Пример, который мы видели ранее, отлично подходит здесь.

~~~
attack() {
  return `${super.attack()} HA!`;
}
~~~
