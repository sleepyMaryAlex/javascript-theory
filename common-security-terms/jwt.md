# ?JWT

_JSON Web Token (JWT)_ — это открытый стандарт (RFC 7519) для создания токенов доступа, основанный на формате JSON. Как правило, используется для передачи данных для аутентификации в клиент-серверных приложениях.

> Аутентифика́ция (англ. authentication – реальный, подлинный) — процедура проверки подлинности. В нашем случае, мы проверяем логин + пароль на совпадение с записью в базе данных пользователей.

> Авториза́ция (англ. authorization — разрешение, уполномочивание) — предоставление пользователю прав на выполнение определённых действий, а также процесс проверки (подтверждения) данных прав при попытке выполнения этих действий.

> Другими словами, аутентификация проверяет легальность пользователя, а затем, если все хорошо, пользователь становится авторизированным, то есть может выполнять разрешенные действия с базой данных. Обычно, эти два процесса совмещаются, поэтому и возникает известная путанница.

Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который в дальнейшем использует данный токен для подтверждения своей личности. Токены представляет собой альтернативу логину и паролю.

В простом понимании — это строка в специальном формате, которая содержит данные, например, ID и имя зарегистрированного пользователя. Она передается при каждом запросе на сервер, когда необходимо идентифицировать и понять, кто прислал этот запрос.

Для дальнейших разборов используется токен:

~~~
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9.E4FNMef6tkjIsf7paNrWZnB88c3WyIfjONzAeEd4wF0
~~~

После того, как посетитель прошел авторизацию в нашей системе, указав свой логин и пароль, система выдает ему 2 токена: `access token` и `refresh token`.

После чего посетитель, когда хочет получить с сервера данные, например, свой профиль, вместе с запросом он передает Access токен, как в примере выше.

Сервер, получив его проверяет, что он действительный (об этом чуть ниже), вычитывает полезные данные из него (тот же `user id`) и, таким образом, может идентифицировать пользователя.

### Структура JWT

Токен разделен на три основные группы: заголовок `header`, полезные данные `payload` и подпись `signature`, разделенные между собой точкой.

#### Header

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9` - это первая часть токена, заголовок. Она закодирована в Base64 и если её раскодировать, получим строку:

~~~
{ "alg":"HS256","typ":"JWT" }
~~~

Это можно проверить в браузере, выполнив в консоле или js коде:

~~~
const header = atob('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9');
console.log(header);
~~~

> Функция `atob()` декодирует строку данных, закодированную с использованием кодировки Base64.

`typ` - это наш тип токена JWT. `Alg` - алгоритм шифрования HMAC-SHA256. Он будет использоваться при создании подписи. Для его вычисления нужен лишь один секретный ключ.

Еще может использоваться другой алгоритм `RS256` — в отличие от предыдущего, он является ассиметричным и создает два ключа: публичный и приватный. С помощью приватного ключа создается подпись, а с помощью публичного только лишь проверяется подлинность подписи, поэтому нам не нужно беспокоиться о его безопасности.

#### Payload

Вторым блоком идет `eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9`.

Это есть полезные данные, так же закодированные в Base64. После раскодирования получим:

~~~
{"user_id":1,"exp":1581357039}
~~~

Данные могут быть любыми. Главное, чтобы по ним можно было идентифицировать пользователя. В нашем случае - это `user_id` и `exp` - время окончания действия текущего токена.

Вы можете положить столько заявок, сколько захотите. Существует список стандартных заявок для `JWT payload` — вот некоторые из них:

* `iss (issuer)` — определяет приложение, из которого отправляется токен.

~~~
"iss": "Online JWT Builder"
~~~

* `sub (subject)` — определяет тему токена.

~~~
"sub": "uid"
~~~

* `exp (expiration time)` — время жизни токена.

~~~
"exp": 1448333419
~~~

Стоит помнить, что чем больше передается информации, тем больший получится в итоге сам JWT. Обычно с этим не бывает проблем, но все-таки это может негативно сказаться на производительности и вызвать задержки во взаимодействии с сервером.

#### Signature

Последняя часть токена - наиболее важная. У нас это `E4FNMef6tkjIsf7paNrWZnB88c3WyIfjONzAeEd4wF0`.

Как вы уже могли заметить - первые данные передаются практически в открытом виде и раскодировать их может любой. Но шифровать их нет необходимости. Цель токена - подтвердить, что эти данные не были изменены.

Вот для этих целей и выступает сигнатура. И чтобы её сгенерировать нужен приватный ключ. Ну или некая секретная фраза, которая находится только на сервере. Только с помощью этого ключа мы можем создать сигнатуру и проверить, что она была создана именно с помощью его.

Она получается примерно следующим образом:

1. Берем заголовок, например `{"alg":"HS256","typ":"JWT"}` и кодируем его в `base64`, получаем ту самую часть `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`
2. Тоже самое проделываем с данными `eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9`
3. После этого склеиваем их и получаем `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9`
4. Далее эти данные шифруем с помощью нашего алгоритма HMAC-SHA256 и ключа

Условный псевдокод:

~~~
const header = '{"alg":"HS256","typ":"JWT"}' // строка
const payload = '{"user_id":1,"exp":1581357039}' // строка

// кодируем заголовок и данные в base64
const headerBase64 = base64urlEncode(header)
const payloadBase64 = base64urlEncode(payload)

// склеиваем точкой полученные строки
const data = headerBase64 + '.' + payloadBase64

// кодируем алгоритмом шифрования нашим ключем шифрования
const secret = '123456'
const sig = HMAC-SHA256(data, secret)
~~~

> _Кодирование_ предназначено для обеспечения удобства использования данных и может быть отменено путем использования того же алгоритма, который кодировал содержимое, т. е. без использования ключа.

> _Шифрование_ предназначено для сохранения конфиденциальности данных и требует использования ключа (держится в секрете) для возврата к открытому тексту.

#### Теперь объединим все три JWT компонента вместе

~~~
// и, наконец, получаем окончательный токен
const jwt = data + '.' + sig
~~~

### Проверка JWT

Для проверка токена необходимо проделать ту же операцию.

Берем склейку заголовок + данные, кодируем с помощью алгоритма HMAC-SHA256 и нашего приватного ключа. А далее берем сигнатуру с токена и сверяем с результатом кодирования. Если результаты совпадают - значит данные подтверждены и можно быть уверенным, что они не были подменены.

### Виды токенов

* __Токены доступа (JWT)__ — это токены, с помощью которых можно получить доступ к защищенным ресурсам. Они короткоживущие, но многоразовые. В них может содержаться дополнительная информация, например, время жизни или IP-адрес, откуда идет запрос. Все зависит от желания разработчика.

Минус: пользователю придется перелогиниваться каждый раз, когда у такого токена истечет срок жизни. Пользователю это рано или поздно надоест и он уйдет с нашего ресурса.

* __Рефреш токен (RT)__ — эти токены выполняют только одну специфичную задачу — получение нового токена доступа. Они долгоживущие, но одноразовые.

### Refresh token

Основной токен (access токен), обычно имеет короткий срок жизни - 15-30 минут. Больше давать не стоит.

Как только время выйдет, пользователю снова придется проходить авторизацию. Так вот чтобы этого избежать, существует Refresh токен. С помощью него можно продлить Access токен.

В действительности, Refresh токен обязательно должен быть одноразовым. Его задача - получить новую пару токенов. Как только это было сделано, предыдущий токен будет считаться недействительным. Срок жизни Refresh токена уже может быть большим - до года, а может даже и больше.

У него, обычно, нет какой-то структуры и это может быть некая случайная строка.

Для проекта `odo24.ru` используется следующий подход.

1. Генерируется Access токен и после случайная строка, например `T6cjEbghMZmybUd_fhE`
2. С нашего нового Access токена `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9.E4FNMef6tkjIsf7paNrWZnB88c3WyIfjONzAeEd4wF0` берутся последние шесть знаков `Ed4wF0`
3. Склеивается рефреш токен `T6cjEbghMZmybUd_fhEEd4wF0`

Это сделано для привязки Access токена к Refresh.

Для получения новых токенов необходимо передать эти два токена. Делается проверка на их связку и только после валидируется Access токен. Если и второй этап прошел успешно, тогда получаем с базы данных по текущему `user_id` рефреш токен и сверяем с тем, что к нам пришел. Если они совпадают, тогда генерируются новые токены и в базе данных обновляется Refresh токен на новый.

### Где хранить токены?

Можно разделить оба токена и хранить в разных местах. Access токен нужен только для идентификации пользователя и на клиенте (JS) он не нужен, поэтому он передается в `Cookie` (http only).

Refresh токен хранится в `LocalStorage` и используется только когда Access токен перестал быть актуальным.

### Зачем 2 токена?

Представим ситуацию, когда у нас каким-то образом украли Access токен. Да, это уже плохо и где-то у нас брешь в безопасности. Злоумышленник в этом случае сможет им воспользоваться не более чем на 15-30 минут. После чего токен "протухнет" и перестанет быть актуальным. Ведь нужен второй токен для продления.

Если украли Refresh токен, то без Access токена (который недоступен в JS) он оказывается просто бесполезным.

Самая неприятная ситуация - это когда удалось увести сразу 2 токена. В этом случае злоумышленник сможет пользоваться системой неограниченное время. Точнее когда пользователь попытается войти в систему, его не пустит, т.к. его Refresh токен уже будет неактуальным, и ему придется вводить логин и пароль. Только в этом случае злоумышленник потеряет контроль над чужой учетной записью.
