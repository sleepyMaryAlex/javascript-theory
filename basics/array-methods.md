# ?Arrays methods

### Remove and add methods:

__push()__ - добавляет один или более элементов в конец массива и возвращает новую длину массива.

__pop()__ - удаляет последний элемент из массива и возвращает его значение.

__unshift()__ - добавляет один или более элементов в начало массива и возвращает новую длину массива.

__shift()__ - удаляет первый элемент из массива и возвращает его значение.

> Можно удалить элемент по индексу: delete trees[3];

### Search methods

__indexOf()__ - возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.
`arr.indexOf(searchElement[, fromIndex = 0]);`

__lastIndexOf()__ - возвращает последний индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет. Массив просматривается от конца к началу, начиная с индекса `fromIndex`.

__includes()__ - определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.

__find()__ - возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции. В противном случае возвращается undefined.

~~~
const animals = ['Dodo', 'Tiger', 'Penguin'];
console.log(animals.find((animal) => animal.length === 4)); // 'Dodo'
~~~

__findLast()__ - возвращает значение последнего найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции. В противном случае возвращается undefined.

__findIndex()__ - возвращает индекс в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае возвращается -1.

### Merging methods

__concat()__ - возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.

### Modification methods

__map()__ - создаёт и возвращает новый массив с результатом вызова указанной функции для каждого элемента массива. Не изменяет начальный массив.

~~~
const numbers = [1, 4, 9];
const doubles = numbers.map((num) => num * 2); // [2, 8, 18]
~~~

### Getting a single value from an array of elements

__reduce()__ - применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.

`array.reduce(callback[, initialValue]);`

Callback принимает четыре аргумента:

* Аккумулятор, аккумулирующий значение, которое возвращает функция `callback` после посещения очередного элемента, либо значение `initialValue`, если оно предоставлено.
* Текущий обрабатываемый элемент массива.
* Индекс текущего обрабатываемого элемента массива.
* Массив, для которого была вызвана функция `reduce`.

~~~
const array = ['h', 'e', 'l', 'l', 'o'];
const sum = array.reduce((previous, current) => previous + current);
console.log(sum); // hello
~~~

__reduceRight()__ - применяет функцию к аккумулятору и каждому значению массива (справа-налево), сводя его к одному значению.

~~~
const array = ['h', 'e', 'l', 'l', 'o'];
const sum = array.reduceRight((previous, current) => previous + current);
console.log(sum); // olleh
~~~

### How to copy array part

__slice()__ - возвращает новый массив, содержащий копию части исходного массива.

~~~
const arr = [1, 2, 3, 4, 5];
console.log(arr.slice(0, 2));
// [1, 2]
~~~

Способы скопировать массив целиком. Изменения в `copiedArr` не затронут `arr`:

~~~
const arr = [1, 2, 3, 4, 5];
const copiedArr = [].concat(arr);
const copiedArr = arr.slice(0);
const copiedArr = [...arr];
~~~

### How to flatten nested array

__flat()__ - возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень `depth`.

~~~
const nestedArray = [[1, 2], [3, [4, 5, [6]]]];
console.log(nestedArray.flat(3));
~~~

`flatten`, который не принимает параметров:

~~~
const nestedArray = [[1, 2], [3, [4, 5, [6]]]];
Array.prototype.flatten = function() {
  let result = [];
  for (const value of this) {
    if (Array.isArray(value)) {
      result.push(...value.flatten());
    } else {
      result.push(value);
    }
  }
  return result;
}

console.log(nestedArray.flatten()); // [1, 2, 3, 4, 5, 6]
~~~

__flatMap()__ возвращает новый массив, сформированный путем применения заданной функции обратного вызова к каждому элементу массива и последующего рекурсивного "поднятия" на один уровень. Объединяет `flat()` и `map()`.

~~~
const arr = [1, 2, [3], [4], 6, []];
const flattened = arr.flatMap(num => num * 2);
console.log(flattened);  // [2, 4, 6, 8, 12, 0]
~~~

### Sorting methods

__sort()__ - на месте сортирует элементы массива (не создает копию) и возвращает отсортированный массив.
Порядок сортировки по умолчанию соответствует порядку кодовых точек Unicode. Например, слово "Вишня" идёт перед словом "бананы". Поскольку числа преобразуются в строки, то "80" идёт перед "9" в соответствии с порядком в Unicode.

~~~
const numbers = [1, 7, 3, 4, 5];
numbers.sort((x, y) => {
  if (x > y) {
    return 1;
  }
  if (x < y) {
    return -1;
  }
  return 0;
});

// [1, 3, 4, 5, 7]
// Меняет массив numbers
~~~

### Filter methods

__filter()__ - создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции. Не изменяет начальный массив.
~~~
const numbers = [1, 7, 3, 4, 5];
const result = numbers.filter((num) => num > 3);
// result = [7, 4, 5]
~~~

### Iteration methods

__forEach()__ - выполняет указанную функцию один раз для каждого элемента в массиве. Возвращает undefined.

### Other methods

__at()__ - принимает значение в виде целого числа и возвращает элемент массива с данным индексом. Например, для получения последнего элемента, вместо `array[array.length-1]` можно вызвать `array.at(-1)`.

__copyWithin()__ - копирует последовательность элементов массива внутри него в позицию, начинающуюся по индексу target.
`arr.copyWithin(target, start[, end = this.length]);`

Параметры:

* `target` - начальный индекс позиции цели, куда копировать элементы.
* `start` - начальный индекс позиции источника, откуда начинать копировать элементы.
* `end` - необязательный параметр. Конечный индекс позиции источника, где заканчивать копировать элементы, не включая элемент на позиции end.

`console.log([1, 2, 3, 4, 5].copyWithin(0, 3)); // [4, 5, 3, 4, 5]`
`console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4)); // [4, 2, 3, 4, 5]`

__entries()__ - возвращает новый объект итератора массива Array Iterator, содержащий пары ключ / значение для каждого индекса в массиве.

~~~
const arr = ['a', 'b', 'c'];
const iterator = arr.entries();
console.log(iterator.next().value); // [0, 'a']
console.log(iterator.next().value); // [1, 'b']
console.log(iterator.next().value); // [2, 'c']
~~~

__every()__ - проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.
`console.log([12, 54, 18, 130, 44].every(elem => elem >= 10)); // true`

__some()__ - проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции. Возвращает true или false.

__fill()__ - заполняет все элементы массива от начального до конечного индексов одним значением.
`arr.fill(value[, start = 0[, end = this.length]]);`

Примеры:
~~~
console.log([1, 2, 3].fill(4)); // [4, 4, 4]
console.log([1, 2, 3].fill(4, 1)); // [1, 4, 4]
console.log([1, 2, 3].fill(4, 1, 2)); // [1, 4, 3]
~~~

__Array.from()__ - создаёт новый массив из итерируемого или подобного массиву объекта.
~~~
const arr = [1, 2, 3];
console.log(Array.from(arr, (x) => x * 2)); // [2, 4, 6]
~~~

__Array.isArray()__ - проверяет, является ли переданное значение массивом.

__join()__ - создает и возвращает новую строку путем объединения всех элементов массива, разделенных запятыми или заданной строкой-разделителем.

__keys()__ - возвращает новый объект Array Iterator, содержащий ключи для каждого индекса в массиве.
~~~
const array = ['a', 'b', 'c'];
const iterator = array.keys();
for (const key of iterator) {
  console.log(key); // 0 1 2
}
~~~

Альтернативный способ итерации:
`console.log(iterator.next());`

__values()__ - возвращает новый объект итератора массива Array Iterator, содержащий значения для каждого индекса в массиве.

__Конструктор Array()__ используется для создания массивов. Массив инициализируется заданными элементами, за исключением случая, когда конструктору передается один аргумент, и этот аргумент является числом. В этом случае он возвращает новый массив с свойством length, равным этому числу.
~~~
Array(7); // [ <7 empty items> ]
Array(1, 2, 3); // [1, 2, 3]
~~~

__Array.of()__ - создаёт новый экземпляр массива из произвольного числа аргументов.
Разница между Array.of() и конструктором Array: Array.of(7) создаёт массив с одним элементом 7, а Array(7) создаёт пустой массив со значением свойства length равным 7.
~~~
Array.of(7); // [7]
Array.of(1, 2, 3); // [1, 2, 3]
~~~

__reverse()__ - на месте обращает порядок следования элементов массива. Первый элемент массива становится последним, а последний — первым.

__splice()__ - изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
~~~
const myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
const removed = myFish.splice(2, 1, 'drum');
console.log(myFish); // ['angel', 'clown', 'drum', 'sturgeon']
console.log(removed); // ['mandarin']
~~~

__toString()__ - возвращает строковое представление указанного массива и его элементов.
~~~
const date = new Date();
const array = [date, 'good morning'];
console.log(array.toString()); // Wed Sep 21 2022 10:34:00 GMT+0300 (Moscow Standard Time),good morning
~~~

__toLocaleString()__ - возвращает строковое представление элементов массива.
~~~
const date = new Date();
const array = [date, 'good morning'];
console.log(array.toLocaleString()); // 9/21/2022, 10:33:08 AM,good morning
~~~

> Методы `push`, `shift`, `unshift`, `pop`, `reverse`, `splice`, `sort`, `copyWithin`, `fill` мутируют массив!

### Array properties

Массив имеет несколько свойств, например `arguments`, `length` и другие.
