# ?Basic Operators

JavaScript поддерживает бинарные и унарные операторы, а также ещё один специальный тернарный оператор - условный оператор. Бинарная операция использует два операнда, один перед оператором и другой за ним.
`operand1 operator operand2`

В свою очередь унарная операция использует один операнд, перед или после оператора:
Например: `x++` или `++x`.

### Операторы присваивания:

Основным оператором присваивания является `=`, он присваивает значение правого операнда операнду, находящемуся слева.

`x = y`

Существуют также составные операторы присваивания, которые используются для сокращённого представления операций:

`x += y`
`x %= y`
и т.д.

### Операторы сравнения:

Оператор сравнения сравнивает свои операнды и возвращает логическое значение, базируясь на истинности сравнения. Операнды могут быть числами, строками, логическими величинами или объектами.

~~~
== // сравнивает по значению
!=
=== // сравнивает по типу и значению
!==
>
>=
<
<=
~~~

### Арифметические операторы:

`+ - * / % **`

`Декремент, инкремент`

`Унарные плюс и минус`

### Побитовые операторы:

Побитовые операторы работают следующим образом:

1. Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть, если она есть, отбрасывается.
2. Для бинарных операторов – каждый бит в первом операнде рассматривается вместе с соответствующим битом второго операнда: первый бит с первым, второй со вторым и т.п. Оператор применяется к каждой паре бит, давая соответствующий бит результата.
3. Получившаяся в результате последовательность бит интерпретируется как обычное число.

Вспомогательные функции `parseInt`, `toString`:

* `parseInt("11000", 2)` – переводит строку с двоичной записью числа в число.
* `n.toString(2)` – получает для числа `n` запись в 2-ной системе в виде строки.

__& (Побитовое И)__

Выполняет операцию И над каждой парой бит.

Результат `a & b` равен единице только когда оба бита `a` и `b` равны единице.

Пример:

~~~
9 (по осн. 10)
  = 00000000000000000000000000001001 (по осн. 2)
14 (по осн. 10)
  = 00000000000000000000000000001110 (по осн. 2)
14 & 9 (по осн. 10)
  = 00000000000000000000000000001000 (по осн. 2)
  = 8 (по осн. 10)
~~~

__| (Побитовое ИЛИ)__

Выполняет операцию ИЛИ над каждой парой бит. Результат `a | b` равен `1`, если хотя бы один бит из `a`, `b` равен `1`.

Пример:

~~~
9 (по осн. 10)
  = 00000000000000000000000000001001 (по осн. 2)
14 (по осн. 10)
  = 00000000000000000000000000001110 (по осн. 2)
14 | 9 (по осн. 10)
  = 00000000000000000000000000001111 (по осн. 2)
  = 15 (по осн. 10)
~~~

__^ (Исключающее ИЛИ)__

`a | b` равно `1`, если только `a = 1` или только `b = 1`, но не оба одновременно `a = b = 1`.

Пример:

~~~
9 (по осн. 10)
  = 00000000000000000000000000001001 (по осн. 2)
14 (по осн. 10)
  = 00000000000000000000000000001110 (по осн. 2)
14 ^ 9 (по осн. 10)
  = 00000000000000000000000000000111 (по осн. 2)
  = 7 (по осн. 10)
~~~

__~ (Побитовое НЕ)__

Производит операцию НЕ над каждым битом, заменяя его на обратный ему.

Пример:

~~~
 9 (по осн. 10)
  = 00000000000000000000000000001001 (по осн. 2)
~9 (по осн. 10)
  = 11111111111111111111111111110110 (по осн. 2)
  = -10 (по осн. 10)
~~~

__<< (Битовый сдвиг влево)__

Операторы битового сдвига принимают два операнда. Первый – это число для сдвига, а второй – количество битов, которые нужно сдвинуть в первом операнде.

Оператор << сдвигает первый операнд на указанное число битов влево. Лишние биты отбрасываются, справа добавляются нулевые биты.

Например, `9 << 2` даст `36`:

~~~
9 (по осн.10)
  = 00000000000000000000000000001001 (по осн.2)
9 << 2 (по осн.10)
  = 00000000000000000000000000100100 (по осн.2)
  = 36 (по осн.10)
~~~

Операция `<< 2` сдвинула и отбросила два левых нулевых бита и добавила справа два новых нулевых.

Левый сдвиг почти равен умножению на 2.

Битовый сдвиг `<< N` обычно имеет тот же эффект, что и умножение на два `N` раз, например:

~~~
alert( 3 << 1 ); // 6, умножение на 2
alert( 3 << 2 ); // 12, умножение на 2 два раза

alert( 3 << 3 ); // 24, умножение на 2 три раза
~~~

Конечно, следует иметь в виду, что побитовые операторы работают только с 32-битными числами, поэтому верхний порог такого «умножения» ограничен.

__>> (Правый битовый сдвиг, переносящий знак)__

Этот оператор сдвигает биты вправо, отбрасывая лишние. При этом слева добавляется копия крайнего-левого бита.

Пример. `-9 >> 2` даст `-3`:

~~~
-9 (по осн.10)
  = 11111111111111111111111111110111 (по осн.2)
-9 >> 2 (по осн.10)
  = 11111111111111111111111111111101 (по осн.2) = -3 (по осн.10)
~~~

Правый сдвиг почти равен целочисленному делению на 2.

Битовый сдвиг `>> N` обычно имеет тот же результат, что и целочисленное деление на два `N` раз:

~~~
alert( 100 >> 1 ); // 50, деление на 2
alert( 100 >> 2 ); // 25, деление на 2 два раза
alert( 100 >> 3 ); // 12, деление на 2 три раза, целая часть от результата
~~~

__>>> (Правый сдвиг с заполнением нулями)__

Этот оператор сдвигает биты первого операнда вправо. Лишние биты справа отбрасываются. Слева добавляются нулевые биты.

Знаковый бит становится равным `0`, поэтому результат всегда положителен. Знаковый бит — бит, который показывает знак числа: положительное число (ноль) или отрицательное число.

ECMAScript делает все возможное, чтобы скрыть от вас всю "кухню". Например, при выводе отрицательного числа в виде двоичной строки вы получаете двоичный код абсолютного значения со знаком «минус>. 

`console.log(18..toString(2)) // 10010`
`console.log(-18..toString(2)) // -10010`

> Две точки после числа - это не опечатка. Нужно для тго, чтобы JavaScript понял, что это не десятичная часть начинается, а метод.

Например, `(-314).toString(2)` должно быть `"11111111111111111111111011000110"`, а показывает "`-100111010"`.
