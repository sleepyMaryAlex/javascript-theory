# ?Loops (for loop, while loop, do while loop)
_Циклы_ - простой способ сделать какое-то действие несколько раз. 

Операторы предназначенные для организации циклов в JavaScript:

* Цикл_for
* Цикл_do...while
* Цикл_while
* Метка (label)
* break
* continue
* for...in
* for...of

### Цикл for

```for ([начало]; [условие]; [шаг]) выражения```

При его выполнении происходит следующее:

1. Выполняется выражение начало, если оно указано. Это выражение обычно инициализирует один или несколько счётчиков, но синтаксис позволяет выражению быть любой сложности. Также используется для объявления переменных.
2. Выполняется условие. Если условие истинно, то выполняются выражения. Если оно ложно, цикл for прерывается. Если же условие полностью пропущено, то оно считается истинным.
3. Выполняются выражения. Чтобы выполнить несколько выражений, используются блок-выражение `{ ... }` для группировки выражений.
4. Обновляется шаг, если он есть, а затем управление возвращается к шагу 2. Шаг выполняется после тела цикла на каждой итерации перед проверкой условия. И не важно, как мы написали шаг (`i++` или `++i`). Различие между постфиксным и префиксным операторами инкремента состоит в возвращаемом значении выражения. Так как в приведенных примерах циклов результаты выражений не используются, то для циклов никакой разницы нет.

Любая часть for может быть пропущена.
А можно и вообще убрать всё, получив бесконечный цикл:

```for (;;) { // будет выполняться вечно }```

Можно и так:
~~~
for (let x = 0, y = 10; x <= 10; x++, y--) {
 console.log(x, y);
}
~~~

### Цикл do...while

Цикл `do` выполнится минимум 1 раз

~~~
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
~~~

### Цикл while

Цикл while выполняет выражения пока условие истинно.

~~~
let n = 0;
while (n < 3) {
  console.log(n);
  n++;
}
~~~

### Метки для break/continue

Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.

~~~
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Значение на координатах (${i},${j})`, ''); // если пустая строка или отмена, то выйти из обоих циклов
    if (!input) break outer; // (*) // сделать что-нибудь со значениями...
  }
}
~~~

Когда вы используете continue с меткой, он применяется к циклу с этой меткой.

~~~
let i = 0;
let j = 8;
checkiandj:
while (i < 4) {
  console.log('checkiandj ' + i);
  i += 1;
  checkj:
    while (j > 4) {
      console.log('checkj ' + j);
      j -= 1;
      if ((j % 2) != 0) {
       continue checkiandj;
      }
      console.log(j + " чётное.");
    }
  console.log("i = " + i);
  console.log("j = " + j);
}
~~~

Прерывание цикла: _«break»_
Обычно цикл завершается при вычислении условия в false.
Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.

Переход к следующей итерации: _continue_
Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).

break/continue не могут быть использованы с тернарным оператором ?.

### for...in

Цикл пройдёт по всем перечисляемым свойствам объекта, а также тем, что он унаследует от конструктора прототипа (свойства объекта в цепи прототипа).

~~~
let obj = {model: 'AUDI A8', year: '2019', color: 'brown'}

for (key in obj) {
  console.log(`${key} = ${obj[key]}`);
}
// model = AUDI A8
// year = 2019
// color = brown
~~~

Хотя, очень заманчиво использовать for...in как способ пройтись по всем элементам Array, этот оператор возвращает имя свойств определённых пользователем помимо числовых индексов. Таким образом лучше использовать стандартный for для числовых индексов при взаимодействии с массивами, поскольку оператор for...in проходит по определённым пользователем свойствам в дополнение к элементам массива, если вы изменяете массив, например, добавляете свойства и методы. Нет гарантии, что for...in будет возвращать индексы в конкретном порядке. Цикл for...in возвращает все перечисляемые свойства, включая имеющие нецелочислиненные имена и наследуемые.

~~~
let arr = ['AUDI A8', '2019', 'brown'];
arr.cost = '$100.000';

for (key in arr) {
  console.log(`${key} = ${arr[key]}`);
}

// 0 = AUDI A8
// 1 = 2019
// 2 = brown
// cost = $100.000
~~~

Если вы хотите рассматривать только свойства самого объекта, а не его прототипов, используйте getOwnPropertyNames(), hasOwnProperty() или propertyIsEnumerable.
Следующая функция иллюстрирует использование hasOwnProperty(): наследуемые свойства не отображаются:

~~~
const triangle = { a:1, b:2, c:3 };

function ColoredTriangle() {
  this.color = "red";
}

ColoredTriangle.prototype = triangle;

const obj = new ColoredTriangle();

for (const prop in obj) {
  if( obj.hasOwnProperty(prop) ) {
    console.log("obj." + prop + " = " + obj[prop]);
  }
}

// Выведет:
// "obj.color = red"
~~~

### for...of
Оператор for...of выполняет цикл обхода итерируемых объектов (en-US) (включая Array, Map (en-US), Set, объект аргументов (en-US) и подобных)

__Различия между for...of и for...in__

Оба оператора, и for...in и for...of производят обход объектов. Разница в том, как они это делают.
Тогда как for...in проходит по именам свойств, for...of проходит по значениям свойств.
Для for...in обход перечисляемых свойств объекта осуществляется в произвольном порядке. Например, если в массиве пропущены элементы, то for in их не будет перечислять как undefined.
Для for...of обход происходит в соответствии с тем, какой порядок определён в итерируемом объекте.

~~~
const arr = ['AUDI A8'];
arr.cost = '$100.000';
arr[3] = 'Tesla'

for (key in arr) {
  console.log(arr[key]);
} 
// AUDI A8
// Tesla
// $100.000

for (value of arr) {
  console.log(value);
}
// AUDI A8
// undefined
// undefined
// Tesla
~~~
