# ?Comparison Operators

Все операторы сравнения возвращают значение логического типа.

Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный»  порядок.  Используется кодировка Unicode, а не настоящий алфавит. Например, в JavaScript имеет значение регистр символов. Заглавная буква `"A"` не равна строчной `"a"`. Какая же из них больше? Строчная `"a"`. Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode). 

При сравнении значений разных типов JavaScript приводит каждое из них к числу.

`alert( '01' == 1 ); // true, строка '01' становится числом 1`

`console.log(true == '-1'); // false`

Логическое значение `true` становится `1`, а `false` – `0`.

`alert( true == 1 ); // true`

`alert( false == 0 ); // true`

Еще интересный пример:

`'' == '0'; // false`

`0 == ''; // true`

`0 == '0'; // true`

Использование обычного сравнения == может вызывать проблемы. Например, оно не отличает `0` от `false`.

`alert( 0 == false ); // true`

Оператор строгого равенства `===` проверяет равенство без приведения типов. Оператор строгого равенства делает код более очевидным и оставляет меньше места для ошибок.

`alert( 0 === false ); // false, так как сравниваются разные типы`

Поведение `null` и `undefined` при сравнении с другими значениями — особое:
При строгом равенстве `===` эти значения различны, так как различны их типы.

`alert( null === undefined ); // false`

При нестрогом равенстве `==` эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.

`alert( null == undefined ); // true`

`console.log(null == ''); // false. Значение null равно только null или undefined и ничему больше.`

При использовании математических операторов и других операторов сравнения `<` `>` `<=` `>=` значения `null`/`undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.

Странный результат сравнения `null` и `0`

`alert( null > 0 ); // false`

`alert( null == 0 ); // false`

`alert( null >= 0 ); // true`

Несравненное значение `undefined`

`alert( undefined > 0 ); // false`

`alert( undefined < 0 ); // false`

`alert( undefined == 0 ); // false`

Почему же сравнение `undefined` с нулём всегда ложно?

На это есть следующие причины:

* Сравнения (1) и (2) возвращают `false`, потому что `undefined` преобразуется в `NaN`, а `NaN` – это специальное числовое значение, которое возвращает `false` при любых сравнениях.
* Нестрогое равенство (3) возвращает `false`, потому что `undefined` равно только `null`, `undefined` и ничему больше.

`5 > 4 → true`

`"ананас" > "яблоко" → false, "а" меньше, чем "я".`

`"2" > "12" → true, cнова посимвольное сравнение`

`undefined == null → true`

`undefined === null → false`

`null == "\n0\n" → false`

`null === +"\n0\n" → false`
