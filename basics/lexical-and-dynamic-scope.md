# ?Lexical scope | dynamic scope

Функциям в ECMAScript присуща лексическая область видимости.

_Лексическая область видимости_ - это область видимости, которая определяется в момент определения функции (в отличие от динамической области видимости, при которой область видимости определяется в момент вызова функции).

Давайте разберем на практике такой пример:
~~~
let a = 3;

function foo() {
  console.log(a); // 5, так как лексическая область заботится о том, где была объявлена функция
}

function bar() {
  const a = 10;
  console.log(a); // 10
  foo();
}

a = 5;
bar();
~~~

При выполнении этого примера сначала вызывается функция `bar`, которая сначала выведет значение переменной `a` и затем вызовет функцию `foo`. В области видимости функции `bar` переменная `a` "затеняет" переменную, объявленную в глобальной области видимости и поэтому функция `bar` выведет — `10`. Далее вызовется функция `foo`, которая тоже отображает значение переменной `a`, только в этой функции оно является числом `5`.

Так как лексические области видимости (связи переменных с их идентификаторами) формируются на этапе лексического разбора, а не на этапе выполнения программы, то переменная `a` в функции `foo` будет взята из родительской (для `foo`) области видимости, где её значение — `5`.

То есть сначала, еще до выполнения самой программы, произойдет следующее:

* Лексический анализатор дойдет до строки функции `foo`:

```console.log(a);```

в которой запрашивается переменная по идентификатору `a`.

* Лексический анализатор начнет поиск этой переменной, начиная с текущей области видимости, где эта переменная запрашивается (в функции `foo`).
* Не найдя переменную в локальной области видимости, лексический анализатор обратится к окружению функции `foo` и найдет её в родительской области видимости, где такая переменная объявлена.
* Лексический анализатор установит связь между этой переменной из родительской области видимости и идентификатором, который запрашивается в `foo`.

Поэтому несмотря на то, что `foo` вызывается из функции `bar`, где объявлена своя переменная `a`, функция `foo` выведет значение той переменной, которая была зафиксирована во время лексического анализа, то есть число `5`.

__Но почему функция `foo` отображает переменную `a`, где ее значение `5`, а не `3`?__

Создав функцию, мы невольно сохраняем и цепочку областей видимости функции, которая в свою очередь представляет из себя цепочку из объекта вызова, содержащего локальные переменные, и из глобального объекта стоящего в цепочке на уровень выше.

Здесь есть одна тонкость. Цепочка областей видимости функции, представляет из себя грубо говоря цепочку объектов. Это очень важно понять, так как объекты в JavaScript хранятся в виде ссылок, то есть каждый элемент цепочки ссылается на определенный объект (именно ссылается а не содержит его копию), который в ходе выполнения программы может меняться. То есть объект из цепочки области видимости может меняться какими то внешними функциями, при этом все изменения будут доступны и в функции, в чью цепочку областей видимости входит изменяемый объект. Другими словами цепочка областей видимости фиксируется в момент определения функции, но перечень свойств, определенных в этой цепочке, не фиксируется. Цепочка областей видимости подвержена изменениям, и функция может обращаться ко всем элементам, существующим на момент исполнения.

__Ключевое сравнение__: _лексическая область_ заботится о том, где была объявлена функция, а _динамическая область_ - о том, откуда была вызвана функция. JavaScript, на самом деле, не имеет динамической области видимости. Он имеет только лексическую область. А вот механизм `this` подобен динамической области видимости.

> Два механизма в JavaScript могут "обмануть" лексическую область видимости: `eval(..)` и `with`. 
