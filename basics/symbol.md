# ?Symbol

По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.

До сих пор мы видели только строки. Теперь давайте разберём символы, увидим, что хорошего они дают.

### Символы

«Символ» представляет собой уникальный идентификатор.

Создаются новые символы с помощью функции `Symbol()`:

~~~
// Создаём новый символ - id
const id = Symbol();
~~~

При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

~~~
// Создаём символ id с описанием (именем) "id"
const id = Symbol("id");
~~~

Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.

Например, вот два символа с одинаковым описанием – но они не равны:

~~~
const id1 = Symbol("id");
const id2 = Symbol("id");

console.log(id1 == id2); // false
console.log(id1 === id2); // false
~~~

### Преобразование типа символа

Большинство типов данных в JavaScript могут быть неявно преобразованы в строку. Например, функция `alert` принимает практически любое значение, автоматически преобразовывает его в строку, а затем выводит это значение, не сообщая об ошибке. Символы же особенные и не преобразуются автоматически.

К примеру, `alert` ниже выдаст ошибку:

~~~
const id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string
~~~

Это – языковая «защита» от путаницы, ведь строки и символы – принципиально разные типы данных и не должны неконтролируемо преобразовываться друг в друга.

Если же мы действительно хотим вывести символ с помощью `alert`, то необходимо явно преобразовать его с помощью метода `.toString()`, вот так:

~~~
const id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает
~~~

Или мы можем обратиться к свойству `symbol.description`, чтобы вывести только описание:

~~~
const id = Symbol("id");
alert(id.description); // id
~~~

При попытке преобразовать символ в число будет выдано сообщение об ошибке `TypeError`:

~~~
const sym = Symbol("1");
console.log(+sym); // TypeError: Cannot convert a Symbol value to a number
~~~

При использовании нестрогого равенства `Object(sym) == sym` возвращает `true`.

~~~
const sym = Symbol("1");
console.log(Object(sym) == sym); // true
console.log(Object(sym) === sym); // false

console.log(sym == sym); // true
console.log(sym === sym); // true
~~~

### «Скрытые» свойства

Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.

Например, мы работаем с объектами `user`, которые принадлежат стороннему коду. Мы хотим добавить к ним идентификаторы.

Используем для этого символьный ключ:

~~~
const user = {
  name: "Вася",
};

const id = Symbol("id");

user[id] = 1;

console.log(user[id]); // 1, мы можем получить доступ к данным по ключу-символу
~~~

Почему же лучше использовать `Symbol("id")`, а не строку `"id"`?

Так как объект `user` принадлежит стороннему коду, и этот код также работает с ним, то нам не следует добавлять к нему какие-либо поля. Это небезопасно. Но к символу сложно нечаянно обратиться, сторонний код вряд ли его вообще увидит, и, скорее всего, добавление поля к объекту не вызовет никаких проблем.

Кроме того, предположим, что другой скрипт для каких-то своих целей хочет записать собственный идентификатор в объект `user`. Этот скрипт может быть какой-то JavaScript-библиотекой, абсолютно не связанной с нашим скриптом.

Сторонний код может создать для этого свой символ `Symbol("id")`:

~~~
// ...
const id = Symbol("id");

user[id] = "Их идентификатор";
~~~

Конфликта между их и нашим идентификатором не будет, так как символы всегда уникальны, даже если их имена совпадают.

А вот если бы мы использовали строку `"id"` вместо символа, то тогда был бы конфликт:

~~~
const user = { name: "Вася" };

// Объявляем в нашем скрипте свойство "id"
user.id = "Наш идентификатор";

// ...другой скрипт тоже хочет свой идентификатор...

user.id = "Их идентификатор"
// Ой! Свойство перезаписано сторонней библиотекой!
~~~

### Символы в литеральном объекте

Если мы хотим использовать символ при литеральном объявлении объекта `{...}`, его необходимо заключить в квадратные скобки.

~~~
const id = Symbol("id");

const user = {
  name: "Вася",
  [id]: 123, // просто "id: 123" не сработает
};
~~~

Это вызвано тем, что нам нужно использовать значение переменной `id` в качестве ключа, а не строку `«id»`.

### Символы игнорируются циклом `for..in`

Свойства, чьи ключи – символы, не перебираются циклом `for..in`.

~~~
const id = Symbol("id");

const user = {
  name: "Вася",
  age: 30,
  [id]: 123,
};

for (const key in user) {
  console.log(key); // name, age (свойства с ключом-символом нет среди перечисленных)
}

// хотя прямой доступ по символу работает
console.log("Напрямую: " + user[id]);
~~~

Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство. `Object.keys(user)` также игнорирует символы.

А вот `Object.assign`, в отличие от цикла `for..in`, копирует и строковые, и символьные свойства:

~~~
const id = Symbol("id");

const user = {
  [id]: 123,
};

const clone = Object.assign({}, user);

console.log(clone[id]); // 123
~~~

Здесь нет никакого парадокса или противоречия. Так и задумано. Идея заключается в том, что, когда мы клонируем или объединяем объекты, мы обычно хотим скопировать все свойства (включая такие свойства с ключами-символами, как, например, `id` в примере выше).

### Глобальные символы

Итак, как мы видели, обычно все символы уникальны, даже если их имена совпадают. Но иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью. Например, разные части нашего приложения хотят получить доступ к символу `"id"`, подразумевая именно одно и то же свойство.

Для этого существует глобальный реестр символов. Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.

Для чтения (или, при отсутствии, создания) символа из реестра используется вызов `Symbol.for(key)`.

Он проверяет глобальный реестр и, при наличии в нём символа с именем `key`, возвращает его, иначе же создаётся новый символ `Symbol(key)` и записывается в реестр под ключом `key`.

~~~
// читаем символ из глобального реестра и записываем его в переменную
const id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
const idAgain = Symbol.for("id");

// проверяем => это один и тот же символ
console.log(id === idAgain); // true
~~~

Символы, содержащиеся в реестре, называются глобальными символами. Если вам нужен символ, доступный везде в коде – используйте глобальные символы.

### `Symbol.keyFor`

Для глобальных символов, кроме `Symbol.for(key)`, который ищет символ по имени, существует обратный метод: `Symbol.keyFor(sym)`, который, наоборот, принимает глобальный символ и возвращает его имя.

~~~
// получаем символ по имени
const sym = Symbol.for("name");
const sym2 = Symbol.for("id");

// получаем имя по символу
console.log(Symbol.keyFor(sym)); // name
console.log(Symbol.keyFor(sym2)); // id
~~~

Внутри метода `Symbol.keyFor` используется глобальный реестр символов для нахождения имени символа. Так что этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт `undefined`.

Впрочем, для любых символов доступно свойство `description`.

~~~
const globalSymbol = Symbol.for("name");
const localSymbol = Symbol("name");

console.log(Symbol.keyFor(globalSymbol)); // name, глобальный символ
console.log(Symbol.keyFor(localSymbol)); // undefined для неглобального символа

console.log(localSymbol.description); // name
~~~

### Системные символы

Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.

Эти символы перечислены в спецификации в таблице [Well-known symbols](https://tc39.es/ecma262/#sec-well-known-symbols):

* `Symbol.hasInstance`
* `Symbol.isConcatSpreadable`
* `Symbol.iterator`
* `Symbol.toPrimitive`
* …и так далее.

В частности, `Symbol.toPrimitive` позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву.

`Symbol.toPrimitive` следует использовать для обозначения метода преобразования, вот так:

~~~
const user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    console.log(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  },
};

// демонстрация результатов преобразований:
console.log(String(user));
// hint: string
// {name: "John"}
console.log(+user);
// hint: number
// 1000
console.log(user + 500);
// hint: default
// 1500
~~~

Как мы можем видеть из кода, `user` становится либо строкой со своим описанием, либо суммой денег в зависимости от преобразования. Единый метод `user[Symbol.toPrimitive]` обрабатывает все случаи преобразования.

### Хинты

Как JavaScript решает, какое преобразование применить?

Существует три варианта преобразования типов, которые происходят в различных ситуациях. Они называются «хинтами».

* `"string"` - для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку.
* `"number"` - для преобразования объекта к числу, в случае математических операций.
* `"default"` - происходит редко, когда оператор «не уверен», какой тип ожидать.

