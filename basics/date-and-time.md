# ?Date & time

Встроенный объект `Date` содержит дату и время, а также предоставляет методы управления ими. Нельзя создать «только дату» или «только время»: объекты `Date` всегда содержат и то, и другое.

Например, его можно использовать для хранения времени создания/изменения, для измерения времени или просто для вывода текущей даты.

### Создание

Для создания нового объекта `Date` нужно вызвать конструктор `new Date()` с одним из следующих аргументов:

* `new Date()`

Без аргументов – создать объект `Date` с текущими датой и временем:

~~~
const now = new Date();
console.log(now); // показывает текущие дату и время
~~~

* `new Date(milliseconds)`

Создать объект `Date` с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.

~~~
// Локальный часовой пояс не хранится в объекте даты, а определяется хост-средой (устройством пользователя)
const Jan01_1970 = new Date(0);
console.log(Jan01_1970); // Thu Jan 01 1970 01:00:00 GMT+0100 (Central European Standard Time)

// теперь добавим 24 часа и получим 02.01.1970
const Jan01_1970 = new Date(24 * 3600 * 1000);
console.log(Jan01_1970); // Fri Jan 02 1970 01:00:00 GMT+0100 (Central European Standard Time)
~~~

Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется timestamp.

_Timestamp_ – легковесное численное представление даты. Из таймстампа всегда можно получить дату с помощью `new Date(timestamp)` и преобразовать существующий объект `Date` в таймстамп, используя метод `date.getTime()` (см. ниже).

Датам до 1 января 1970 будут соответствовать отрицательные таймстампы, например:

~~~
// 31 декабря 1969 года
const Dec31_1969 = new Date(-24 * 3600 * 1000);
console.log( Dec31_1969 ); // Wed Dec 31 1969 01:00:00 GMT+0100 (Central European Standard Time)
~~~

* `new Date(datestring)`

Если аргумент всего один, и это строка, то из неё «прочитывается» дата. Алгоритм разбора – такой же, как в `Date.parse`, который мы рассмотрим позже.

~~~
const date = new Date("2017-01-26");
console.log(date); // Thu Jan 26 2017 01:00:00 GMT+0100 (Central European Standard Time)
// Время не указано, поэтому оно ставится в полночь по Гринвичу и меняется в соответствии с часовым поясом места выполнения кода
~~~

* `new Date(year, month, date, hours, minutes, seconds, ms)`

Создать объект `Date` с заданными компонентами в местном часовом поясе. Обязательны только первые два аргумента.

1. `year` должен состоять из четырёх цифр. Для совместимости также принимаются 2 цифры и рассматриваются как 19xx, к примеру, 98 здесь это тоже самое, что и 1998, но настоятельно рекомендуется всегда использовать 4 цифры.
2. `month` начинается с 0 (январь) по 11 (декабрь).
3. Параметр `date` здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.
4. Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.

Например:

~~~
console.log(new Date(2011, 0, 1, 0, 0, 0, 0)); // Sat Jan 01 2011 00:00:00 GMT+0100 (Central European Standard Time)
console.log(new Date(2011, 0, 1)); // то же самое, так как часы и проч. равны 0
~~~

Максимальная точность – 1 мс (до 1/1000 секунды):

~~~
const date = new Date(2011, 0, 1, 2, 3, 4, 567);
console.log(date); // Sat Jan 01 2011 02:03:04 GMT+0100 (Central European Standard Time)
~~~

### Получение компонентов даты

Существуют методы получения года, месяца и т.д. из объекта `Date`:

* `getFullYear()` - получить год (4 цифры)
* `getMonth()` - получить месяц, от 0 до 11.
* `getDate()` - получить день месяца, от 1 до 31, что несколько противоречит названию метода.
* `getHours()`, `getMinutes()`, `getSeconds()`, `getMilliseconds()` - получить, соответственно, часы, минуты, секунды или миллисекунды.

##### Никакого `getYear()`. Только `getFullYear()`

Многие интерпретаторы JavaScript реализуют нестандартный и устаревший метод `getYear()`, который порой возвращает год в виде двух цифр. Пожалуйста, обходите его стороной. Если нужно значение года, используйте `getFullYear()`.

Кроме того, можно получить определённый день недели:

* `getDay()` - вернуть день недели от 0 (воскресенье) до 6 (суббота). Несмотря на то, что в ряде стран за первый день недели принят понедельник, в JavaScript начало недели приходится на воскресенье.

Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом.

Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: `getUTCFullYear()`, `getUTCMonth()`, `getUTCDay()`. Для их использования требуется после "get" подставить "UTC".

Если ваш местный часовой пояс смещён относительно UTC, то следующий код покажет разные часы:

~~~
// текущая дата
const date = new Date();

// час в вашем текущем часовом поясе
console.log(date.getHours()); // 15

// час в часовом поясе UTC+0 (лондонское время без перехода на летнее время)
console.log(date.getUTCHours()); // 13
~~~

Помимо вышеприведённых методов, существуют два особых метода без UTC-варианта:

* `getTime()` - для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.

* `getTimezoneOffset()` - возвращает разницу в минутах между UTC и местным часовым поясом:

~~~
// если вы в часовом поясе UTC-1, то выводится 60
// если вы в часовом поясе UTC+3, выводится -180
console.log(new Date().getTimezoneOffset()); // -120
~~~

### Установка компонентов даты

Следующие методы позволяют установить компоненты даты и времени:

* `setFullYear(year, [month], [date])`
* `setMonth(month, [date])`
* `setDate(date)`
* `setHours(hour, [min], [sec], [ms])`
* `setMinutes(min, [sec], [ms])`
* `setSeconds(sec, [ms])`
* `setMilliseconds(ms)`
* `setTime(milliseconds)` (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)

У всех этих методов, кроме `setTime()`, есть UTC-вариант, например: `setUTCHours()`.

Как мы видим, некоторые методы могут устанавливать сразу несколько компонентов даты, например: `setHours`. Если какая-то компонента не указана, она не меняется.

~~~
const today = new Date();

today.setHours(0);
console.log(today); // Wed May 03 2023 00:18:02 GMT+0200 (Central European Summer Time)

today.setHours(0, 0, 0, 0);
console.log(today); // Wed May 03 2023 00:00:00 GMT+0200 (Central European Summer Time)
~~~

### Остальные методы

`toDateString()` - преобразует часть даты объекта `Date` в удобочитаемую форму.
`toISOString()`	- возвращает дату в виде строки, отформатированной в соответствии со стандартом ISO.
`toJSON()` - возвращает дату в виде строки в формате даты JSON.
`toLocaleDateString()` - возвращает часть даты объекта `Date` в виде строки локального формата.
`toLocaleTimeString()` - возвращает временную часть объекта `Date` в виде строки локального формата.
`toLocaleString()` - преобразует объект `Date` в строку локального формата.
`toString()` - преобразует объект `Date` в строку.
`toTimeString()` - преобразует временную часть объекта `Date` в строку.
`toUTCString()` - преобразует объект `Date` в строку по всемирному времени.
`Date.UTC()` - возвращает количество миллисекунд в объекте `Date` с 1 января 1970 года, 00:00:00 (полночь), универсальное время.
`valueOf()` - возвращает примитивное значение объекта `Date`.

~~~
const date = new Date();
console.log(date); //  Wed May 03 2023 16:43:49 GMT+0200 (Central European Summer Time)
console.log(date.toDateString()); // Wed May 03 2023
console.log(date.toISOString()); // 2023-05-03T14:44:30.310Z
console.log(date.toJSON()); // 2023-05-03T14:44:30.310Z
console.log(date.toLocaleDateString()); // 5/3/2023
console.log(date.toLocaleTimeString()); // 4:45:21 PM
console.log(date.toLocaleString()); // 5/3/2023, 4:45:56 PM
console.log(date.toString()); // Wed May 03 2023 16:47:18 GMT+0200 (Central European Summer Time)
console.log(date.toTimeString()); // 16:48:04 GMT+0200 (Central European Summer Time)
console.log(date.toUTCString()); // Wed, 03 May 2023 14:48:17 GMT
console.log(date.valueOf()); // 1683125238480
~~~

### Автоисправление даты

_Автоисправление_ – это очень полезная особенность объектов `Date`. Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит.

~~~
const date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
console.log(date); // ...1st Feb 2013!
~~~

Неправильные компоненты даты автоматически распределяются по остальным.

Предположим, нам требуется увеличить дату «28 февраля 2016» на два дня. В зависимости от того, високосный это год или нет, результатом будет «2 марта» или «1 марта». Нам об этом думать не нужно. Просто прибавляем два дня. Объект `Date` позаботится об остальном:

~~~
const date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

console.log(date); // 1 Mar 2016
~~~

Эту возможность часто используют, чтобы получить дату по прошествии заданного отрезка времени. Например, получим дату «спустя 70 секунд с текущего момента»:

~~~
const date = new Date();
date.setSeconds(date.getSeconds() + 70);

console.log(date); // выводит правильную дату
~~~

Также можно установить нулевые или даже отрицательные значения. Например:

~~~
const date = new Date(2016, 0, 2);
console.log(date); // Sat Jan 02 2016 00:00:00 GMT+0100 (Central European Standard Time)

date.setDate(1);
console.log(date); // Fri Jan 01 2016 00:00:00 GMT+0100 (Central European Standard Time)

date.setDate(0);
console.log(date); // Thu Dec 31 2015 00:00:00 GMT+0100 (Central European Standard Time)
~~~

### Преобразование к числу, разность дат

Если объект `Date` преобразовать в число, то получим таймстамп по аналогии с `date.getTime()`:

~~~
const date = new Date();
console.log(+date); // 1683120528684, количество миллисекунд, то же самое, что date.getTime()
~~~

Важный побочный эффект: даты можно вычитать, в результате получаем разность в миллисекундах.

Этот приём можно использовать для измерения времени:

~~~
const start = new Date(); // начинаем отсчёт времени

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  // do something
}

const end = new Date(); // заканчиваем отсчёт времени

console.log(`Цикл отработал за ${end - start} миллисекунд`);
~~~

### `Date.now()`

Семантически метод `Date.now()` эквивалентен `new Date().getTime()`, однако метод не создаёт промежуточный объект `Date`. Так что этот способ работает быстрее и не нагружает сборщик мусора.

Данный метод используется из соображений удобства или когда важно быстродействие, например, при разработке игр на JavaScript или других специализированных приложений.

Вероятно, предыдущий пример лучше переписать так:

~~~
const start = Date.now(); // количество миллисекунд с 1 января 1970 года

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  // do something
}

const end = Date.now(); // заканчиваем отсчёт времени

console.log(`Цикл отработал за ${end - start} миллисекунд`);  // вычитаются числа, а не даты
~~~

### Бенчмаркинг

Будьте внимательны, если хотите точно протестировать производительность функции, которая зависит от процессора.

Например, сравним две функции, вычисляющие разницу между двумя датами: какая сработает быстрее?

Подобные вычисления, замеряющие производительность, также называют _бенчмарками_ (benchmark).

~~~
function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(func) {
  const date1 = new Date(0);
  const date2 = new Date();

  const start = Date.now();
  for (let i = 0; i < 100000; i++) {
    func(date1, date2);
  }
  return Date.now() - start;
}

console.log("Время diffSubtract: " + bench(diffSubtract) + "мс"); // Время diffSubtract: 9мс
console.log("Время diffGetTime: " + bench(diffGetTime) + "мс"); // Время diffGetTime: 2мс
~~~

Обе функции делают буквально одно и то же, только одна использует явный метод `date.getTime()` для получения даты в миллисекундах, а другая полагается на преобразование даты в число. Результат их работы всегда один и тот же.

Но какая функция быстрее?

Если запустить их много раз подряд, то можно увидеть разницу. В нашем случае функции очень простые, так что потребуется хотя бы 100000 повторений.

Вот это да! Метод `getTime()` работает ощутимо быстрее! Всё потому, что не производится преобразование типов, и интерпретаторам такое намного легче оптимизировать.

Замечательно, это уже что-то. Но до хорошего бенчмарка нам ещё далеко.

Представьте, что при выполнении `bench(diffSubtract)` процессор параллельно делал что-то ещё, также потребляющее ресурсы. А к началу выполнения `bench(diffGetTime)` он это уже завершил.

Достаточно реалистичный сценарий в современных многопроцессорных операционных системах.

В итоге у первого бенчмарка окажется меньше ресурсов процессора, чем у второго. Это может исказить результаты.

##### Для получения наиболее достоверных результатов тестирования производительности весь набор бенчмарков нужно запускать по нескольку раз.

Например, так:

~~~
function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(func) {
  const date1 = new Date(0);
  const date2 = new Date();

  const start = Date.now();
  for (let i = 0; i < 100000; i++) {
    func(date1, date2);
  }
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// bench(diffSubtract) и bench(diffGetTime) поочерёдно запускаются 10 раз
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

console.log("Итоговое время diffSubtract: " + time1); // Итоговое время diffSubtract: 77
console.log("Итоговое время diffGetTime: " + time2); // Итоговое время diffGetTime: 8
~~~

Современные интерпретаторы JavaScript начинают применять продвинутые оптимизации только к «горячему коду», выполняющемуся несколько раз (незачем оптимизировать то, что редко выполняется). Так что в примере выше первые запуски не оптимизированы должным образом. Нелишним будет добавить предварительный запуск для «разогрева»:

// добавляем для "разогрева" перед основным циклом

~~~
bench(diffSubtract);
bench(diffGetTime);

// а теперь тестируем производительность
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
~~~

##### Будьте осторожны с микробенчмарками

Современные интерпретаторы JavaScript выполняют множество оптимизаций. Они могут повлиять на результаты «искусственных тестов» по сравнению с «нормальным использованием», особенно если мы тестируем что-то очень маленькое, например, работу оператора или встроенной функции. Поэтому если хотите серьёзно понять производительность, изучите, как работают интерпретаторы JavaScript. И тогда вам, вероятно, уже не понадобятся микробенчмарки.

> Порой нам нужно измерить время с большей точностью. Собственными средствами JavaScript измерять время в микросекундах (одна миллионная секунды) нельзя, но в большинстве сред такая возможность есть. К примеру, в браузерах есть метод `performance.now()`, возвращающий количество миллисекунд с начала загрузки страницы с точностью до микросекунд (корректными являются только 3 цифры после точки).

### Разбор строки с датой

Метод `Date.parse(str)` считывает дату из строки.

Формат строки должен быть следующим: `YYYY-MM-DDTHH:mm:ss.sssZ`, где:

`YYYY-MM-DD` – это дата: год-месяц-день.
Символ `T` используется в качестве разделителя.
`HH:mm:ss.sss` – время: часы, минуты, секунды и миллисекунды.
Необязательная часть `Z` обозначает часовой пояс в формате `+-hh:mm`. Если указать просто букву `Z`, то получим UTC+0.
Возможны и более короткие варианты, например, `YYYY-MM-DD` или `YYYY-MM`, или даже `YYYY`.

Вызов `Date.parse(str)` обрабатывает строку в заданном формате и возвращает таймстамп (количество миллисекунд с 1 января 1970 года UTC+0). Если формат неправильный, возвращается `NaN`.

~~~
const ms = Date.parse("2012-01-26T13:51:50.417-07:00");
console.log(ms); // 1327611110417 (таймстамп)
~~~

Можно тут же создать объект `new Date` из таймстампа:
~~~
const date = new Date(ms);
console.log(date); // Thu Jan 26 2012 21:51:50 GMT+0100 (Central European Standard Time)
~~~

### GMT vs UTC

_GMT (Greenwich Mean Time)_, обозначающее среднее время по Гринвичу, основано на астрономических наблюдениях. _GMT_ — это стандарт времени в стране.

_UTC (Coordinated Universal Time)_ — означает Всемирное координированное время, является международной шкалой времени, рекомендованной Международным бюро мер и весов (BIPM) в качестве правовой основы для времени. Это метод измерения времени использует атомные часы.

> Интересно отметить, что к UTC добавляются дополнительные секунды, чтобы компенсировать замедление вращения Земли. Важно знать, что високосные секунды используются, чтобы позволить UTC отслеживать среднее солнечное время в Королевской обсерватории в Гринвиче, Лондон.

Разница во времени между UTC и GMT составляет доли секунды. Поэтому для общих целей оба времени считаются одинаковыми. Но разница во времени важна для научных целей.

Методы `getUTC*` возвращают компонент даты или времени в соответствии с универсальным временем, тогда как `get*` методы возвращают их в соответствии с местным временем (часовым поясом, в котором находится компьютер посетителя).

Методы` get*` возвращают разные результаты в зависимости от того, откуда пользователь посещает ваш сайт.

Время UTC совпадает с текущим временем по Гринвичу.

~~~
const date = new Date();
console.log(date.toUTCString()); // Fri, 05 May 2023 09:20:38 GMT
~~~

### Utils

Узнать, вчерашняя ли это дата:

~~~
function isYesterday(date) {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);

  return (
    date.getDate() === yesterday.getDate() &&
    date.getMonth() === yesterday.getMonth() &&
    date.getFullYear() === yesterday.getFullYear()
  );
}
~~~

Узнать, сколько времени осталось:

~~~
function getTimeLeft(expiredAt) {
  const now = new Date();
  const expiredAtDate = new Date(expiredAt);
  const timeLeft = new Date(expiredAtDate.getTime() - now.getTime());

  const years = timeLeft.getUTCFullYear() - 1970;
  const months = timeLeft.getUTCMonth();
  const days = timeLeft.getUTCDate() - 1;

  if (years < 0) {
    return `No time`;
  } else if (years > 0) {
    return `More than ${years} ${years === 1 ? 'year' : 'years'}`;
  } else if (months > 0) {
    return `${months} ${months === 1 ? 'month' : 'months'}`;
  } else if (days > 0) {
    return `${days} ${days === 1 ? 'day' : 'days'}`;
  } else {
    return 'Less than a day';
  }
}
~~~
