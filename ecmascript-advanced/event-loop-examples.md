# ?Event loop. Examples

### Разбиение «тяжёлой» задачи

Допустим, у нас есть задача, требующая значительных ресурсов процессора.

Например, подсветка синтаксиса (используется для выделения цветом участков кода на этой странице) – довольно процессороёмкая задача. Для подсветки кода надо выполнить синтаксический анализ, создать много элементов для цветового выделения, добавить их в документ – для большого текста это требует значительных ресурсов.

Пока движок занят подсветкой синтаксиса, он не может делать ничего, связанного с DOM, не может обрабатывать пользовательские события и т.д. Возможно даже «подвисание» браузера, что совершенно неприемлемо.

Мы можем избежать этого, разбив задачу на части. Сделать подсветку для первых 100 строк, затем запланировать `setTimeout` (с нулевой задержкой) для разметки следующих 100 строк и т.д.

Чтобы продемонстрировать такой подход, давайте будем использовать для простоты функцию, которая считает от 1 до 1000000000.

Если вы запустите код ниже, движок «зависнет» на некоторое время. Для серверного JS это будет явно заметно, а если вы будете выполнять этот код в браузере, то попробуйте понажимать другие кнопки на странице – вы заметите, что никакие другие события не обрабатываются до завершения функции счёта.

~~~
let i = 0;

const start = Date.now();

function count() {
  // делаем тяжёлую работу
  for (let j = 0; j < 1e9; j++) {
    i++;
  }

  console.log("Done in " + (Date.now() - start) + "ms"); // Done in 1096ms
}

count();
~~~

Браузер может даже показать сообщение «скрипт выполняется слишком долго».

Давайте разобьём задачу на части, воспользовавшись вложенным `setTimeout`:

~~~
let i = 0;

const start = Date.now();

function count() {
  // делаем часть тяжёлой работы (*)
  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    console.log("Done in " + (Date.now() - start) + "ms"); // Done in 7305ms
  } else {
    setTimeout(count); // планируем новый вызов (**)
  }
}

count();
~~~

Теперь интерфейс браузера полностью работоспособен во время выполнения «счёта».

Один вызов `count` делает часть работы `(*)`, а затем, если необходимо, планирует свой очередной запуск `(**)`:

1. Первое выполнение производит счёт: `i = 1…1000000`.
2. Второе выполнение производит счёт: `i = 1000001…2000000`.
3. …и так далее.

Теперь если новая сторонняя задача (например, событие `onclick`) появляется, пока движок занят выполнением 1-й части, то она становится в очередь, и затем выполняется, когда 1-я часть завершена, перед следующей частью. Периодические возвраты в событийный цикл между запусками `count` дают движку достаточно «воздуха», чтобы сделать что-то ещё, отреагировать на действия пользователя.

Отметим, что оба варианта – с разбиением задачи с помощью `setTimeout` и без – сопоставимы по скорости выполнения. Нет большой разницы в общем времени счёта.

Чтобы сократить разницу ещё сильнее, давайте немного улучшим наш код.

Мы перенесём планирование очередного вызова в начало `count()`:

~~~
let i = 0;

const start = Date.now();

function count() {
  // перенесём планирование очередного вызова в начало
  if (i < 1e9 - 1e6) {
    setTimeout(count); // запланировать новый вызов
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    console.log("Done in " + (Date.now() - start) + "ms"); // Done in 4656ms
  }
}

count();
~~~

Теперь, когда мы начинаем выполнять `count()` и видим, что потребуется выполнить `count()` ещё раз, мы планируем этот вызов немедленно, перед выполнением работы.

Если вы запустите этот код, то легко заметите, что он требует значительно меньше времени.

Почему?

Всё просто: как вы помните, в браузере есть минимальная задержка в 4 миллисекунды при множестве вложенных вызовов `setTimeout`. Даже если мы указываем задержку `0`, на самом деле она будет равна `4` мс (или чуть больше). Поэтому чем раньше мы запланируем выполнение – тем быстрее выполнится код.

Итак, мы разбили ресурсоёмкую задачу на части – теперь она не блокирует пользовательский интерфейс, причём почти без потерь в общем времени выполнения.

### Индикация прогресса

Ещё одно преимущество разделения на части крупной задачи в браузерных скриптах – это возможность показывать индикатор выполнения.

Обычно браузер отрисовывает содержимое страницы после того, как заканчивается выполнение текущего кода. Не имеет значения, насколько долго выполняется задача. Изменения в DOM отображаются только после её завершения.

С одной стороны, это хорошо, потому что наша функция может создавать много элементов, добавлять их по одному в документ и изменять их стили – пользователь не увидит «промежуточного», незаконченного состояния. Это важно, верно?

В примере ниже изменения `i` не будут заметны, пока функция не завершится, поэтому мы увидим только последнее значение `i`:

~~~
<div id="progress"></div>

<script>
  function count() {
    for (let i = 0; i < 1e6; i++) {
      i++;
      progress.innerHTML = i;
    }
  }

  count();
</script>
~~~

…Но, возможно, мы хотим что-нибудь показать во время выполнения задачи, например, индикатор выполнения.

Если мы разобьём тяжёлую задачу на части, используя `setTimeout`, то изменения индикатора будут отрисованы в промежутках между частями.

Так будет красивее:

~~~
<div id="progress"></div>

<script>
  let i = 0;

  function count() {
    // сделать часть крупной задачи (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e7) {
      setTimeout(count);
    }
  }

  count();
</script>
~~~

Теперь `<div>` показывает растущее значение `i` – это своего рода индикатор выполнения.

### Делаем что-нибудь после события

В обработчике события мы можем решить отложить некоторые действия, пока событие не «всплывёт» и не будет обработано на всех уровнях. Мы можем добиться этого, обернув код в `setTimeout` с нулевой задержкой.

Например: наше событие `menu-open` генерируется через `setTimeout`, чтобы оно возникло после того, как полностью обработано событие `click`.

~~~
menu.onclick = function () {
  console.log(1);

  setTimeout(() =>
    menu.dispatchEvent(
      new CustomEvent("menu-open", {
        bubbles: true,
      })
    )
  );

  console.log(2);
};

document.addEventListener("menu-open", () => console.log("Вложенное событие"));
// 1 2 Вложенное событие
~~~

Без `setTimeout` порядок вывода был бы: `1 Вложенное событие 2`.

### Что код выведет в консоли?

~~~
setTimeout(function timeout() {
  console.log("Таймаут");
}, 0);

const promise = new Promise(function (resolve, reject) {
  console.log("Создание промиса");
  resolve();
});

promise.then(function () {
  console.log("Обработка промиса");
});

console.log("Конец скрипта");
~~~

1. Создание промиса
2. Конец скрипта
3. Обработка промиса
4. Таймаут

Давайте разберем что здесь происходит.

Изначально в стеке выполнения находится сам скрипт, поэтому сначала выполняется только он.

В первой строке появляется `setTimeout`, который ставит переданный колбэк в очередь макрозадач (macrotask queue) на выполнение.

После этого в переменную `promise` запишется промис. Стоит отметить, что создание промиса в данном случае происходит синхронно. Это значит, что код из переданного колбэка выполнится прямо сейчас. В результате в консоль выведется `"Создание промиса"`.

Далее мы уведомляем потребителя `then`, что хотели бы выполнить переданную функцию после успешного выполнения промиса. Так как промис уже имеет состояние `fulfilled` (мы вызвали `resolve()` при его создании), колбэк из `then` будет немедленно передан в очередь микрозадач (microtask queue) на выполнение.

В конце выполнения скрипта выведется `"Конец скрипта"`.

Скрипт является макрозадачей. Как мы уже знаем, после завершения каждой задачи опустошается очередь микрозадач. В ней находится только ранее переданный в `then` колбэк. В результате его выполнения в консоль выведется `"Обработка промиса"`.

Так как очередь микрозадач опустела, можно продолжить выполнять код из очереди макрозадач. Там сейчас находится только колбэк, который мы передавали `setTimeout`. После его выполнения выведется `"Таймаут"`.

Аналогичный пример:

~~~
console.log("Start");

setTimeout(() => {
  console.log("Timeout 1");

  setTimeout(() => console.log("Timeout 2"), 0);

  const promise = new Promise(function (resolve, reject) {
    console.log("Promise");
    resolve();
  });

  promise.then(function () {
    console.log("Then");
  });
}, 0);

console.log("End");

// Start
// End
// Timeout 1
// Promise
// Then
// Timeout 2
~~~

### Что код выведет в консоли?

~~~
console.log(1);

setTimeout(() => console.log(2));

Promise.resolve().then(() => console.log(3));

Promise.resolve().then(() => setTimeout(() => console.log(4)));

Promise.resolve().then(() => console.log(5));

setTimeout(() => console.log(6));

console.log(7);
~~~

Давайте разберем, что здесь происходит, по шагам.

~~~
console.log(1);
// Первая строка выполняется сразу и выводит 1
// Очереди микрозадач и макрозадач на данный момент пусты

setTimeout(() => console.log(2));
// setTimeout ставит переданный колбэк в очередь макрозадач
// - содержимое очереди макрозадач:
// console.log(2)

Promise.resolve().then(() => console.log(3));
// В очередь микрозадач ставится колбэк, выводящий 3
// - содержимое очереди микрозадач:
// console.log(3)

Promise.resolve().then(() => setTimeout(() => console.log(4)));
// В очередь микрозадач ставится колбэк с setTimeout
// - содержимое очереди микрозадач:
// console.log(3); setTimeout(...4)

Promise.resolve().then(() => console.log(5));
// В очередь микрозадач ставится колбэк, выводящий 5
// - содержимое очереди микрозадач:
// console.log(3); setTimeout(...4); console.log(5)

setTimeout(() => console.log(6));
// setTimeout ставит переданный колбэк в очередь макрозадач
// - содержимое очереди макрозадач:
// console.log(2); console.log(6)

console.log(7);
// Тут же выводит 7
~~~

1. Числа `1` и `7` выводятся сразу же, так как они не используют очереди задач вообще.
2. Далее после окончания основного потока кода срабатывает очередь микрозадач.
  * Её содержимое: `console.log(3)`; `setTimeout(...4)`; `console.log(5)`.
  * Выведется `3` и `5`, а `setTimeout(() => console.log(4))` поставит в конец очереди макрозадач вывод `4`.
  * В очереди макрозадач получается теперь: `console.log(2)`; `console.log(6)`; `console.log(4)`.
3. Очередь микрозадач полностью выполнена, срабатывает очередь макрозадач. Она выведет `2`, `6`, `4`.

Получается вывод `1 7 3 5 2 6 4`.

### Что код выведет в консоли?

~~~
function generateNumber(str) {
  return new Promise((resolve, reject) => {
    const parsed = parseInt(str);
    if (isNaN(parsed)) {
      reject("Not a number");
    } else {
      resolve(parsed);
    }
  });
}

function printNumber(str) {
  generateNumber(str)
    .then((value) => console.log(value))
    .catch((error) => console.error(error))
    .finally(() => console.log("Finally"));
}

printNumber("rty");
printNumber("1");
printNumber("2");
printNumber("fghj");
printNumber("3");

// 1
// 2
// 3
// Not a number
// Not a number
// Finally (5 раз)
~~~

Когда микрозадачи начинают выполняться, они исчерпывают всю очередь микрозадач. Если между микрозадачами в очередь ставятся новые микрозадачи, то они выполняются до тех пор, пока очередь микрозадач не опустеет.

Теперь перепишем пример с использованием `async`/`await`:

~~~
function generateNumber(str) {
  return new Promise((resolve, reject) => {
    const parsed = parseInt(str);
    if (isNaN(parsed)) {
      reject("Not a number");
    } else {
      resolve(parsed);
    }
  });
}

async function printNumber(str) {
  try {
    const value = await generateNumber(str);
    console.log(value);
  } catch (error) {
    console.error(error);
  } finally {
    console.log("Finally");
  }
}

printNumber("rty");
printNumber("1");
printNumber("2");
printNumber("fghj");
printNumber("3");

// Not a number
// Finally
// 1
// Finally
// 2
// Finally
// Not a number
// Finally
// 3
// Finally
~~~

Вызов асинхронной операции помещается в блок `try`, соответственно в блоке `catch` можно получить возникшую ошибку и обработать ее.

Порядок вывода в консоль изменился.
