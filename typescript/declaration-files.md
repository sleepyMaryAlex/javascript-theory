# ?Declaration files

Для установки связи с внешними файлами скриптов Javascript в TS служат декларативные или заголовочные файлы.

Это файлы с расширением `.d.ts`, они описывают синтаксис и структуру функций и свойств, которые могут использоваться в программе, не предоставляя при этом конкретной реализации. Они выполняют своего рода роль оберток над библиотеками JavaScript.

Рассмотрим, как мы можем использовать заголовочные файлы. Иногда в программах на Javascript используются глобальные переменные, которые должны быть видны для всех функций приложения. Например, пусть на веб-странице (или во внешнем подключаемом файле Javascript) в коде `js` определена переменная:

~~~
<body>
  <script>
    let message = "Hello TypeScript!";
  </script>
  <script src="app.js"></script>
</body>
~~~

В данном случае для простоты переменная определена веб-странице, хотя она также могла быть определена во внешнем подключенном `js`-файле.

И, допустим, мы хотим использовать эту переменную message в коде TypeScript в файле `app.ts`:

~~~
console.log(message);
~~~

При запуске приложения компилятор TS не сможет скомпилировать программу, так как для кода TS глобальная переменная пока не существует.

В этом случае нам надо подключать определение глобальной переменной с помощью декларативных файлов.

Для этого добавим в проект новый файл, который назовем `globals.d.ts` и который будет иметь следующее содержимое:

~~~
declare let message: string;
~~~

С помощью ключевого слова `declare` в программу на TS подключается определение глобальной переменной.

То есть у нас получится следующая структура проекта:

~~~
app.ts

globals.d.ts

index.html
~~~

### Компиляция

Если мы компилируем, передавая компилятору в консоли название файла:

~~~
tsc app.ts
~~~

...то в этом случае компилятор не найдет автоматически файл `globals.d.ts`. В этом случае нам надо в файле `app.ts` явно указать расположение файла `globals.d.ts` с помощью директивы `reference`:

~~~
/// <reference path="globals.d.ts" />
console.log(message);
~~~

Если же мы полагаемся на файл конфигурации `tsconfig.json`, просто выполняя команду:

~~~
tsc
~~~

...то директиву `/// <reference path="globals.d.ts" />` можно не указывать.

Подобным образом мы можем подключать другие компоненты кода JavaScript - функции, объекты, классы. Рассмотрим их подключение.

### Функции

index.html
~~~
let message = "Hello TypeScript!";

function hello() {
  console.log(message);
}

function sum(a, b) {
  return a + b;
}
~~~

app.ts
~~~
hello();
 
const result = sum(2, 5);
console.log(result);
~~~

В этом случае подключение в файле `globals.d.ts` выглядело бы так:

~~~
declare function hello(): void;
declare function sum(a: number, b: number): number;
~~~

### Подключение объектов

index.html
~~~
const tom = {
  name: "Tom",
  age: 37,
  print() {
    console.log(`Name: ${this.name}  Age: ${this.age}`);
  }
}
~~~

app.ts
~~~
tom.print();
~~~

globals.d.ts
~~~
declare const tom: { name: string; age: number; print: () => void };
~~~

### Подключение сложных объектов

index.html
~~~
const points = [
  { X: 10, Y: 34 },
  { X: 24, Y: 65 },
  { X: 89, Y: 12 },
];
~~~

Для данного массива объектов в файле `globals.d.ts` мы можем определить соответствующий отдельному объекту интерфейс и подключить массив объектов некоторого интерфейса, который содержит два свойства `X` и `Y`:

~~~
interface IPoint {
  X: number;
  Y: number;
}
declare const points: IPoint[];
~~~

app.ts
~~~
for (const point of points) {
  console.log(`Точка с координатами X = ${point.X}  Y = ${point.Y}`);
}
~~~

### Подключение классов

Рассмотрим последний пример - подключение в Typescript классов, определенных в Javascript. Пусть в коде JavaScript определен следующий класс `Person`:

~~~
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  display() {
    console.log(this.name, this.age);
  }
}
~~~

Для этого класса в файле `globals.d.ts` определим следующее объявление класса:

~~~
declare class Person {
  name: string;
  age: number;
  constructor(name: string, age: number);
  display(): void;
}
~~~

Для класса прописываем все его поля и методы, при этом методы (в том числе конструктор) не имеют реализации, для них только определяются параметры и их типы и тип возвращаемого значения.

app.ts
~~~
const tom = new Person("Tom", 37);
tom.display(); // Tom 37
console.log(tom.name); // Tom
~~~

### Декларативные файлы для популярных библиотек

Выше было рассмотрено использование декларативных файлов для внешнего кода на Javascript.

Однако, как правило, нам приходится взаимодействовать с крупными библиотеками, например, jquery, angularjs, extjs и так далее.

Если мы хотим использовать функционал этих библиотек в коде на TS, то для них надо создать свои файлы определений. И это может быть довольно утомительно в виду сложности библиотек и больших объемов кода.

Но в сообществе TypeScript возникла идея создать общий репозиторий для подобных файлов, чтобы не надо было заново определять свои файлы, а можно бы было взять уже готовые.

Этот репозиторий расположен на гитхабе: https://github.com/DefinitelyTyped/DefinitelyTyped/.

### *.d.ts vs *.ts

`*.ts` — это стандартные файлы TypeScript. Их содержимое будет скомпилировано в JavaScript.

`*.d.ts` — это файлы определения типов, которые позволяют использовать существующий код JavaScript в TypeScript.

### Подробнее о `declare`

В TypeScript ключевое слово `declare` сообщает компилятору, что объект существует (и на него можно ссылаться внутри вашего кода). Он объявляет объект компилятору TypeScript. Короче говоря, это позволяет разработчику использовать объект, объявленный в другом месте.

Компилятор не компилирует этот оператор в JavaScript.

Разработчику может потребоваться использовать ключевое слово `declare`:

* Чтобы использовать глобальную переменную, объявленную в другом файле.
* Чтобы использовать функцию, переменную или класс, сгенерированный другим файлом.
* И т. д.

Много раз ключевое слово `declare` используется в декларативных файлах TypeScript (`.d.ts`).

#### Использование ключевого слова `declare` для объявления ресурсов

Часто коду TypeScript необходимо импортировать ресурсы, например изображения или масштабируемую векторную графику (SVG).

В этих случаях вы должны создать объявление для каждого модуля.

Например, если мы хотим использовать PNG в нашем коде, мы можем создать такое объявление:

~~~
declare module "*.png"
~~~
