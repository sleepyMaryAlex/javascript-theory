# ?Type assertion. Преобразование к типу

_Type assertion_ представляет модель преобразования значения переменной к определенному типу. Обычно в некоторых ситуациях одна переменная может представлять какой-то широкий тип, например, `any` или `union`, которые по факту допускают значения различных типов. Однако при этом нам надо использовать переменную как значение строго определенного типа. И в этом случае мы можем привести к этому типу.

В качестве примера возьмем простейшую задачу - на веб-странице есть `html`-элемент с `id = header`, и мы хотим получить этот элемент, например, чтобы изменить его текст. Для получения элемента по id мы могли бы использовать встроенную js-функцию `document.getElementById()`:

~~~
const header = document.getElementById("header");
header.innerText = "Hello Typescript!";
// 'header' is possibly 'null'.
~~~

Но в TypeScript эта функция возвращает объединение `HTMLElement | null`. То есть возвращаемое значение может представлять `null`, если соответствующий `html`-элемент отсутствует на веб-странице. Вследствие этого обращение к свойству `header.innerText` - к свойству объекта, который может быть `null`, содержит потенциальную ошибку. Поэтому компилятор при компиляции сгенерирует ошибку.

Однако ситуация может быть такова, что мы точно знаем, что у нас на странице есть такой элемент. Есть разные способы для решения этой проблемы, чтобы указать компилятору, что все нормально. И одним из ним является приведение типов с помощью _type assertion_.

Есть две формы приведения. Первая форма заключается в использовании угловых скобок:

~~~
const header = <HTMLElement>document.getElementById("header");
header.innerText = "Hello Typescript!";
~~~

Перед значением в угловых скобках указывается тип, к которому надо выполнить приведение. Так, в данном случае мы получаем объект типа `HTMLElement`.

Вторая форма заключается в применении оператора `as`, после которого указывается тип, к которому надо выполнить преобразование:

~~~
const header = document.getElementById("header") as HTMLElement;
header.innerText = "Hello Typescript!";
~~~

Однако такие преобразования будут иметь силу, если мы точно знаем, что значение может быть преобразовано к целевому типу. Например, на странице есть элемент с `id = header`, поэтому мы можем преобразовать значение к типу `HTMLElement`. Однако если такого элемента нет, то во время выполнения мы опять же получим ошибку.

TypeScript допускает только утверждения типа, которые преобразуются в более конкретную или менее конкретную версию типа. Это правило предотвращает «невозможные» приведения, такие как:

~~~
const x = "hello" as number;
~~~
