# ?Data types

_TypeScript_ — это язык, который является надмножеством JavaScript: поэтому синтаксис JS является законным TS.

TypeScript не считает код JavaScript ошибкой из-за своего синтаксиса. Это означает, что вы можете взять любой работающий код JavaScript и поместить его в файл TypeScript, не беспокоясь о том, как именно он написан.

TypeScript предлагает все функции JavaScript, а также дополнительный слой поверх них: систему типов TypeScript.

TypeScript является строго типизированным языком, и каждая переменная и константа в нем имеет определенный тип. При этом в отличие от Javascript мы не можем динамически изменить ранее указанный тип переменной.

В TypeScript имеются следующие базовые типы:

* `boolean`: логическое значение `true` или `false`
* `number`: числовое значение
* `string`: строки
* `bigint`: позволяет хранить числа больше, чем позволяет тип `number`
* `symbol`: cимволы
* `null` и `undefined`: соответствуют значениям `null` и `undefined` в Javascript
* `Array`: массивы
* `Tuples`: кортежи
* `Enum`: перечисления
* `any`: произвольный тип
* `unknown`: тип `unknown` похож на тип `any` тем, что типу `unknown` можно присваивать любое значение. Однако вы не можете получить доступ к свойствам типа `unknown`, а также вызывать или создавать их. Основное различие между `any` и `unknown` заключается в том, что вы не можете взаимодействовать с переменной типа `unknown`. Это вызывает ошибку компилятора
* `never`: также представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые генерируют или возвращают ошибку и т.п.
* `void`: функция ничего не возвращает

Большинство из этих типов соотносятся с примитивными типами из JavaScript.

### `string`, `number`, `bigint`, `boolean`

Для установки типа применяется знак двоеточия, после которого указывается название типа. Примеры создания переменных:

~~~
const hello: string = "hello world";
const x: number = 10; 
const num: bigint = BigInt(100);
const isValid: boolean = true;
~~~

Но можно в принципе и не указывать тип переменной. В этом случае TypeScript автоматически выведет тип из присваемого данной переменной значения.

### `symbol`

`symbol` создаются путем вызова `Symbol` конструктора.

~~~
let sym: symbol = Symbol("key");
~~~

Символы неизменны и уникальны.

Как и строки, символы можно использовать в качестве ключей для свойств объекта.

`unique symbol` является подтипом `symbol` и создается только из вызова `Symbol()` или `Symbol.for()` или из явных аннотаций типа. Этот тип разрешен только для constобъявлений и `readonly` `static` свойств, и для ссылки на конкретный уникальный символ вам придется использовать оператор `typeof`. Каждая ссылка на уникальный символ подразумевает полностью уникальную идентификацию, привязанную к данному объявлению.

~~~
declare const sym1: unique symbol;
 
const sym2: unique symbol = Symbol();
 
let sym3: typeof sym1 = sym1;

class C {
  static readonly StaticSymbol: unique symbol = Symbol();
}
~~~

Поскольку каждый из них `unique symbol` имеет совершенно отдельную идентичность, никакие два `unique symbol` типа нельзя назначать или сравнивать друг с другом.

~~~
// Если вы определяете свои символы как константы, TypeScript может сделать вывод, что они уникальны.
const sym2 = Symbol("key");
const sym3 = Symbol("key");
 
console.log(sym2 === sym3);
// This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.

// В этом примере TS не ругается, так как они оба относятся к символу типа:
let sym4 = Symbol("key");
let sym5 = Symbol("key");
 
console.log(sym4 === sym5); // false, символы уникальны
~~~

### `any`

`any` описывает данные, тип которых может быть неизвестен на момент написания приложения.

~~~
let someVar: any = "hello";
someVar = 20; 
~~~

Так как здесь применяется тип `any`, то данный код скомпилируется без ошибок, несмотря на смену строкового значения на числовое.

Если переменная определяется без значения и указания типа, и только впоследствии при работе программы ей присваивается значение, тогда считается, что она имеет тип `any`:

~~~
let x; // тип any
x = 10; 
x = "hello";
~~~

Включение флага `noImplicitAny` вызовет ошибку для любых переменных, тип которых неявно выводится как `any`.

~~~
// Parameter 's' implicitly has an 'any' type.
function fn(s) {
  console.log(s);
}
~~~

Анонимные функции немного отличаются от объявлений функций. Когда функция появляется в месте, где TypeScript может определить, как она будет вызываться, параметрам этой функции автоматически присваиваются типы.

~~~
const names = ["Alice", "Bob", "Eve"];

// Contextual typing for function
names.forEach(function (s) {
  console.log(s.toUpperCase());
});
~~~

Этот процесс называется контекстной типизацией, потому что контекст , в котором возникла функция, сообщает, какой тип она должна иметь.

Существует еще один способ включения `noImplicitAny` в параметрах компилятора с помощью параметра `strict`.

Параметр компилятора TypeScript `--noImplicitAny` предотвращает подразумеваемый `any`, но не предотвращает явное использование `any`, как это делает это правило:

.eslintrc.json
~~~
{
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
  },
}
~~~

### `null`, `undefined`

Как и в JavaScript, в TypeScript есть специальные типы `undefined` и `null`, которые принимают соответствующие значения `undefined` и `null`.

Использование `undefined` и `null` зависит от параметра компиляции `strictNullChecks`. По умолчанию он имеет значение `false` и не используется, а это значит, что по умолчанию мы можем применять эти типы, как и в Javascript:

~~~
let a: undefined = undefined;
let b: null = null;
~~~

Но фактически мы можем присваивать значения `undefined` и `null` переменным других типов, например, `number`:

~~~
let x: number = undefined;
console.log(x);
x = null;
console.log(x);
x = 5;
console.log(x);
~~~

В этом плане `null` и `undefined` выступают как подтипы других типов и полезны преимущественно в каких-то операциях, где неизвестен результат - то ли это будет число или строка, то ли это будет `null`. В этом случае, чтобы избежать возможной ошибки, мы можем проверить значение на `undefined` или `null`, собственно как и в Javascript.

В то же время отсутствие проверки для этих типов со стороны компилятора является потенциальным источников багов, поэтому нередко при компиляции применяется параметр `strictNullChecks`. Либо при установке флага при компиляции в консоли (`--strictNullChecks`), либо с помощью установки значения `true` в файле конфигурации `tsconfig.json`.

В этом случае при попытке присвоить значение типа `undefined` или `null` переменной другого типа компилятор при компиляции выбросит ошибку.

Также мы получим ошибку, если значение `undefined` присвоим переменной типа `null` или значение `null` переменной типа `undefined`.

Тем не менее нередки ситуации, когда мы точно не знаем, имеет ли какая-то переменная или параметр функции или конкретное значение или оно отсутствует. Особенно в тех случаях, когда мы получаем значение из вне, например, с помощью запроса к какому-нибудь сетевому ресурсу. В этом случае может потребоваться, чтобы переменная или параметр могли принимать значение `null`. И в этом случае можно использовать `union`. Например:

~~~
let userId: number | null = null;

function printId(id: number | null) {
  if (id === null) {
    console.log("User is missing");
  } else {
    console.log(`User id: ${id}`);
  }
}

printId(userId); // User is missing
userId = 45;
printId(userId); // User id: 45
~~~

Если в параметрах компилятора включен параметр `strict`, то `strictNullChecks` тоже включен.

#### Оператор `!`

Оператор `!` (non-null assertion operator) позволяет указать, что объект не представляет значение `null` и `undefined`. 

~~~
const header: HTMLElement | null = document.getElementById("header");
header!.innerText = "Hello Typescript!";
~~~

Оператор ! ставится после объекта, который теоретически может принимать значение `null` перед обращением к его свойствам и методам.

В то же время надо учитывать, что этот оператор не меняет значения объекта. Например, если объект имеет значение `null` или `undefined`, то данный оператор не поможет. Программа скомпилируется, но при выполнении скрипта программа все равно сгенерирует ошибку:

Поэтому рекомендуется применять данный оператор, когда мы знаем, что объект не равен `null` или `undefined`.

### `unknown`

`unknown` является типобезопасным аналогом `any`. Все может быть назначено `unknown`, но `unknown` не может быть назначено ничему, кроме самого себя и `any`.

~~~
let obj: unknown = "";
let str: string = obj; // Type 'unknown' is not assignable to type 'string'.
~~~

Никакие операции над `unknown` не допускаются без предварительного утверждения или сужения до более конкретного типа.

~~~
// Only equality operators are allowed with unknown
function f1(x: unknown) {
  x == 5;
  x !== 10;
  x >= 0; // Error
  x + 1; // Error
  x * 2; // Error
  -x; // Error
  +x; // Error
}

// No property accesses, element accesses, or function calls
function f2(x: unknown) {
  x.foo; // Error
  x[5]; // Error
  x(); // Error
  new x(); // Error
}

// typeof, instanceof, and user defined type predicates
function f3(x: unknown) {
  if (typeof x === "string" || typeof x === "number") {
    // string | number
  }
  if (x instanceof Error) {
    // Error
  }
  if (isFunction(x)) {
    // Function
  }
}

// keyof unknown
type T40 = keyof any; // string | number | symbol
type T41 = keyof unknown; // never
~~~

### `never`

Тип `never` используется, когда вы уверены, что что-то никогда не произойдет.

Тип `never` присваивается каждому типу; однако ни один тип не может быть назначен `never`(кроме самого себя).

~~~
function throwError(errorMsg: string): never {
  throw new Error(errorMsg);
}

function keepProcessing(): never {
  while (true) {
    console.log("I always does something and never ends.");
  }
}
~~~

### `void`

`void` представляет возвращаемое значение функций, которые не возвращают значение. Это предполагаемый тип всякий раз, когда функция не имеет никаких `return` или не возвращает никакого явного значения:

~~~
function noop(): void {
  return;
}
~~~

Функция, которая не возвращает значение, на самом деле возвращает значение `undefined`. Рассмотрим следующий пример:

~~~
function sayHi(): void {
  console.log("Hi!");
}

const speech: void = sayHi();
console.log(speech); // undefined
~~~

Если вы используете тип `speech: never` вы получите ошибку времени компиляции, так как `void` не может быть назначен `never`.

Однако `void` и `undefined` не одно и то же в TypeScript.

Возвращаемый тип `void` для функций может привести к необычному, но ожидаемому поведению.

Контекстная типизация с возвращаемым типом `void` не заставляет функции ничего не возвращать. По-другому можно сказать, что это тип контекстной функции с возвращаемым типом `void` (`type voidFunc = () => void`), при реализации он может возвращать любое другое значение, но оно будет проигнорировано.

Таким образом, допустимы следующие реализации типа `() => void`:

~~~
type voidFunc = () => void;

const f1: voidFunc = () => {
  return true;
};

const f2: voidFunc = () => true;

const f3: voidFunc = function () {
  return true;
};

const v1 = f1();

const v2 = f2();

const v3 = f3();
~~~

И когда возвращаемое значение одной из этих функций будет присвоено другой переменной, оно сохранит тип `void`:

~~~
const v1 = f1();
~~~

Когда литеральное определение функции имеет возвращаемый тип `void`, эта функция не должна ничего возвращать.

~~~
function f1(): void {
  return true; // Error
}
~~~
