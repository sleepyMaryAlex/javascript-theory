# ?Data types

_TypeScript_ — это язык, который является надмножеством JavaScript: поэтому синтаксис JS является законным TS.

TypeScript не считает код JavaScript ошибкой из-за своего синтаксиса. Это означает, что вы можете взять любой работающий код JavaScript и поместить его в файл TypeScript, не беспокоясь о том, как именно он написан.

TypeScript предлагает все функции JavaScript, а также дополнительный слой поверх них: систему типов TypeScript.

TypeScript является строго типизированным языком, и каждая переменная и константа в нем имеет определенный тип. При этом в отличие от Javascript мы не можем динамически изменить ранее указанный тип переменной.

В TypeScript имеются следующие базовые типы:

* `boolean`: логическое значение `true` или `false`
* `number`: числовое значение
* `string`: строки
* `bigint`: позволяет хранить числа больше, чем позволяет тип `number`
* `symbol`: cимволы
* `null` и `undefined`: соответствуют значениям `null` и `undefined` в Javascript
* `Array`: массивы
* `Tuples`: кортежи
* `Enum`: перечисления
* `any`: произвольный тип
* `unknown`: тип `unknown` похож на тип `any` тем, что типу `unknown` можно присваивать любое значение. Однако вы не можете получить доступ к свойствам типа `unknown`, а также вызывать или создавать их. Основное различие между `any` и `unknown` заключается в том, что вы не можете взаимодействовать с переменной типа `unknown`. Это вызывает ошибку компилятора.
* `never`: также представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые генерируют или возвращают ошибку
* `void`: функция ничего не возвращает

Большинство из этих типов соотносятся с примитивными типами из JavaScript.

### `string`, `number`, `bigint`, `boolean`

Для установки типа применяется знак двоеточия, после которого указывается название типа. Примеры создания переменных:

~~~
const hello: string = "hello world";
const x: number = 10; 
const num: bigint = BigInt(100);
const isValid: boolean = true;
~~~

Но можно в принципе и не указывать тип переменной. В этом случае TypeScript автоматически выведет тип из присваемого данной переменной значения.

### `symbol`

`symbol` создаются путем вызова `Symbol` конструктора.

~~~
let sym: symbol = Symbol("key");
~~~

Символы неизменны и уникальны.

Как и строки, символы можно использовать в качестве ключей для свойств объекта.

`unique symbol` является подтипом `symbol` и создается только из вызова `Symbol()` или `Symbol.for()` или из явных аннотаций типа. Этот тип разрешен только для constобъявлений и `readonly` `static` свойств, и для ссылки на конкретный уникальный символ вам придется использовать оператор `typeof`. Каждая ссылка на уникальный символ подразумевает полностью уникальную идентификацию, привязанную к данному объявлению.

~~~
declare const sym1: unique symbol;
 
const sym2: unique symbol = Symbol();
 
let sym3: typeof sym1 = sym1;

class C {
  static readonly StaticSymbol: unique symbol = Symbol();
}
~~~

Поскольку каждый из них `unique symbol` имеет совершенно отдельную идентичность, никакие два `unique symbol` типа нельзя назначать или сравнивать друг с другом.

~~~
// Если вы определяете свои символы как константы, TypeScript может сделать вывод, что они уникальны.
const sym2 = Symbol("key");
const sym3 = Symbol("key");
 
console.log(sym2 === sym3);
// This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.

// В этом примере TS не ругается, так как они оба относятся к символу типа:
let sym4 = Symbol("key");
let sym5 = Symbol("key");
 
console.log(sym4 === sym5); // false, символы уникальны
~~~

### `any`

`any` описывает данные, тип которых может быть неизвестен на момент написания приложения.

~~~
let someVar: any = "hello";
someVar = 20; 
~~~

Так как здесь применяется тип `any`, то данный код скомпилируется без ошибок, несмотря на смену строкового значения на числовое.

Если переменная определяется без значения и указания типа, и только впоследствии при работе программы ей присваивается значение, тогда считается, что она имеет тип `any`:

~~~
let x; // тип any
x = 10; 
x = "hello";
~~~

Включение флага `noImplicitAny` вызовет ошибку для любых переменных, тип которых неявно выводится как `any`.

~~~
// Parameter 's' implicitly has an 'any' type.
function fn(s) {
  console.log(s);
}
~~~

Анонимные функции немного отличаются от объявлений функций. Когда функция появляется в месте, где TypeScript может определить, как она будет вызываться, параметрам этой функции автоматически присваиваются типы.

~~~
const names = ["Alice", "Bob", "Eve"];

// Contextual typing for function
names.forEach(function (s) {
  console.log(s.toUpperCase());
});
~~~

Этот процесс называется контекстной типизацией, потому что контекст , в котором возникла функция, сообщает, какой тип она должна иметь.

Существует еще один способ включения `noImplicitAny` в параметрах компилятора с помощью параметра `strict`.

Параметр компилятора TypeScript `--noImplicitAny` предотвращает подразумеваемый `any`, но не предотвращает явное использование `any`, как это делает это правило:

.eslintrc.json
~~~
{
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
  },
}
~~~

### `null`, `undefined`

Как и в JavaScript, в TypeScript есть специальные типы `undefined` и `null`, которые принимают соответствующие значения `undefined` и `null`.

Использование `undefined` и `null` зависит от параметра компиляции `strictNullChecks`. По умолчанию он имеет значение `false` и не используется, а это значит, что по умолчанию мы можем применять эти типы, как и в Javascript:

~~~
let a: undefined = undefined;
let b: null = null;
~~~

Но фактически мы можем присваивать значения `undefined` и `null` переменным других типов, например, `number`:

~~~
let x: number = undefined;
console.log(x);
x = null;
console.log(x);
x = 5;
console.log(x);
~~~

В этом плане `null` и `undefined` выступают как подтипы других типов и полезны преимущественно в каких-то операциях, где неизвестен результат - то ли это будет число или строка, то ли это будет `null`. В этом случае, чтобы избежать возможной ошибки, мы можем проверить значение на `undefined` или `null`, собственно как и в Javascript.

В то же время отсутствие проверки для этих типов со стороны компилятора является потенциальным источников багов, поэтому нередко при компиляции применяется параметр `strictNullChecks`. Либо при установке флага при компиляции в консоли (`--strictNullChecks`), либо с помощью установки значения `true` в файле конфигурации `tsconfig.json`.

В этом случае при попытке присвоить значение типа `undefined` или `null` переменной другого типа компилятор при компиляции выбросит ошибку.

Также мы получим ошибку, если значение `undefined` присвоим переменной типа `null` или значение `null` переменной типа `undefined`.

Тем не менее нередки ситуации, когда мы точно не знаем, имеет ли какая-то переменная или параметр функции или конкретное значение или оно отсутствует. Особенно в тех случааях, когда мы получаем значение из вне, например, с помощью запроса к какому-нибудь сетевому ресурсу. В этом случае может потребоваться, чтобы переменная или параметр могли принимать значение `null`. И в этом случае можно использовать `union`. Например:

~~~
let userId: number | null = null;
~~~

#### Оператор `!`

Оператор `!` (non-null assertion operator) позволяет указать, что объект не представляет значение `null` и `undefined`. 

~~~
const header: HTMLElement | null = document.getElementById("header");
header!.innerText = "Hello Typescript!";
~~~

Оператор ! ставится после объекта, который теоретически может принимать значение `null` перед обращением к его свойствам и методам.

В то же время надо учитывать, что этот оператор не меняет значения объекта. Например, если объект имеет значение `null` или `undefined`, то данный оператор не поможет. Программа скомпилируется, но при выполнении скрипта программа все равно сгенерирует ошибку:

Поэтому рекомендуется применять данный оператор, когда мы знаем, что объект не равен `null` или `undefined`.

### `typeof`

С помощью оператора `typeof` мы можем проверить тип переменной. Это может быть необходимо, когда мы хотим выполнить некоторые операции с переменной, но нам неизвестен ее точный тип (например, переменная представляет тип `any`). Данная функциональность еще называется _type guards_ или защита типа:

~~~
let sum: any;
sum = 1200;

if (typeof sum === "number") {
  const result: number = sum / 12;
  console.log(result);
} else {
  console.log("Invalid operation");
}
~~~

Оператор `typeof` может возвращать следующие значения:

* `"string"`
* `"number"`
* `"bigint"`
* `"boolean"`
* `"symbol"`
* `"undefined"`
* `"object"`
* `"function"`
