# ?WebSocket

_WebSocket_ – это современный способ иметь постоянное соединение между браузером и сервером. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.

WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.

### Простой пример

Чтобы открыть веб-сокет-соединение, нам нужно создать объект `new WebSocket`, указав в `url`-адресе специальный протокол `ws`:

~~~
const socket = new WebSocket("ws://javascript.info");
~~~

Также существует протокол `wss://`, использующий шифрование. Это как HTTPS для веб-сокетов.

##### Всегда предпочитайте wss://

Протокол `wss://` не только использует шифрование, но и обладает повышенной надёжностью.

Это потому, что данные `ws://` не зашифрованы, видны для любого посредника. Старые прокси-серверы не знают о WebSocket, они могут увидеть «странные» заголовки и закрыть соединение.

С другой стороны, `wss://` – это WebSocket поверх TLS (так же, как HTTPS – это HTTP поверх TLS), безопасный транспортный уровень шифрует данные от отправителя и расшифровывает на стороне получателя. Пакеты данных передаются в зашифрованном виде через прокси, которые не могут видеть, что внутри, и всегда пропускают их.

Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:

* `open` – соединение установлено,
* `message` – получены данные,
* `error` – ошибка,
* `close` – соединение закрыто.

…А если мы хотим отправить что-нибудь, то вызов `socket.send(data)` сделает это.

Вот пример:

~~~
const socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function() {
  console.log("Соединение установлено. Отправляем данные на сервер");
  socket.send("Меня зовут Джон");
};

socket.onmessage = function(event) {
  console.log(`Данные получены с сервера: ${event.data}`);
};

socket.onclose = function(event) {
  if (event.wasClean) {
    console.log(`Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
  } else {
    // например, сервер убил процесс или сеть недоступна
    // обычно в этом случае event.code 1006
    console.log('Соединение прервано');
  }
};

socket.onerror = function() {
  console.log(`Error`);
};

// Соединение установлено. Отправляем данные на сервер
// Данные получены с сервера: Hello from server, Джон!
// Соединение закрыто чисто, код=1000 причина=Bye!
~~~

Сервер отвечает «Привет с сервера, Джон», после ожидает 5 секунд и закрывает соединение.

Так вы увидите события `open` → `message` → `close`.

### Открытие веб-сокета

Когда `new WebSocket(url)` создан, он тут же сам начинает устанавливать соединение.

Браузер, при помощи специальных заголовков, спрашивает сервер: «Ты поддерживаешь Websocket?» и если сервер отвечает «да», они начинают работать по протоколу WebSocket, который уже не является HTTP.

Вот пример заголовков для запроса, который делает `new WebSocket("wss://javascript.info/chat")`.

~~~
GET /chat
Host: javascript.info
Origin: https://javascript.info
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
Sec-WebSocket-Version: 13
~~~

* `Origin` – источник текущей страницы (например `https://javascript.info`). Заголовок `Origin` важен, так как он позволяет серверу решать, использовать ли WebSocket с этим сайтом.
* `Connection: Upgrade` – сигнализирует, что клиент хотел бы изменить протокол.
* `Upgrade: websocket` – запрошен протокол «websocket».
* `Sec-WebSocket-Key` – случайный ключ, созданный браузером для обеспечения безопасности.
* `Sec-WebSocket-Version` – версия протокола WebSocket, текущая версия 13.

> Мы не можем использовать `XMLHttpRequest` или `fetch` для создания такого HTTP-запроса, потому что JavaScript не позволяет устанавливать такие заголовки.

Если сервер согласен переключиться на WebSocket, то он должен отправить в ответ код `101`:

~~~
101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
~~~

Здесь `Sec-WebSocket-Accept` – это `Sec-WebSocket-Key`, перекодированный с помощью специального алгоритма. Браузер использует его, чтобы убедиться, что ответ соответствует запросу.

### Расширения и подпротоколы

Могут быть дополнительные заголовки `Sec-WebSocket-Extensions` и `Sec-WebSocket-Protocol`, описывающие расширения и подпротоколы.

Например:

* `Sec-WebSocket-Extensions: deflate-frame` означает, что браузер поддерживает сжатие данных. Расширение – это что-то, связанное с передачей данных, расширяющее сам протокол WebSocket. Заголовок `Sec-WebSocket-Extensions` отправляется браузером автоматически со списком всевозможных расширений, которые он поддерживает.

* `Sec-WebSocket-Protocol: soap, wamp` означает, что мы будем передавать не только произвольные данные, но и данные в протоколах SOAP или WAMP (The WebSocket Application Messaging Protocol" – «протокол обмена сообщениями WebSocket приложений»). То есть этот заголовок описывает не передачу, а формат данных, который мы собираемся использовать. Официальные подпротоколы WebSocket регистрируются в [каталоге IANA](https://www.iana.org/assignments/websocket/websocket.xml).

Этот необязательный заголовок ставим мы сами, передавая массив подпротоколов вторым параметром `new WebSocket`, вот так:

~~~
const socket = new WebSocket("wss://javascript.info/chat", ["soap", "wamp"]);
~~~

Сервер должен ответить перечнем протоколов и расширений, которые он может использовать.

Например, запрос:

~~~
...
Sec-WebSocket-Extensions: deflate-frame
Sec-WebSocket-Protocol: soap, wamp
~~~

Ответ:

~~~
...
Sec-WebSocket-Extensions: deflate-frame
Sec-WebSocket-Protocol: soap
~~~

Здесь сервер отвечает, что поддерживает расширение – `deflate-frame` и может использовать только протокол SOAP из всего списка запрошенных подпротоколов.

### Передача данных

Поток данных в WebSocket состоит из «фреймов», фрагментов данных, которые могут быть отправлены любой стороной, и которые могут быть следующих видов:

* «текстовые фреймы» – содержат текстовые данные, которые стороны отправляют друг другу.
* «бинарные фреймы» – содержат бинарные данные, которые стороны отправляют друг другу.
* «пинг-понг фреймы» используется для проверки соединения; отправляется с сервера, браузер реагирует на них автоматически.
* также есть «фрейм закрытия соединения» и некоторые другие служебные фреймы.

В браузере мы напрямую работаем только с текстовыми и бинарными фреймами.

__Метод `send()` может отправлять и текстовые, и бинарные данные.__

Вызов `socket.send(body)` принимает `body` в виде строки или любом бинарном формате включая `Blob`, `ArrayBuffer` и другие. Дополнительных настроек не требуется, просто отправляем в любом формате.

__При получении данных, текст всегда поступает в виде строки. А для бинарных данных мы можем выбрать один из двух форматов: `Blob` или `ArrayBuffer`.__

Это задаётся свойством `socket.binaryType`, по умолчанию оно равно `blob`, так что бинарные данные поступают в виде Blob-объектов.

_Blob_ – это высокоуровневый бинарный объект, он напрямую интегрируется с `<a>`, `<img>` и другими тегами, так что это вполне удобное значение по умолчанию. Но для обработки данных, если требуется доступ к отдельным байтам, мы можем изменить его на `arraybuffer`:

~~~
socket.binaryType = "arraybuffer";
socket.onmessage = (event) => {
  // event.data является строкой (если текст) или arraybuffer (если двоичные данные)
};
~~~

### Ограничение скорости

Представим, что наше приложение генерирует много данных для отправки. Но у пользователя медленное соединение, возможно, он в интернете с мобильного телефона и не из города.

Мы можем вызывать `socket.send(data)` снова и снова. Но данные будут буферизованы (сохранены) в памяти и отправлены лишь с той скоростью, которую позволяет сеть.

Свойство `socket.bufferedAmount` хранит количество байт буферизованных данных на текущий момент, ожидающих отправки по сети.

Мы можем изучить его, чтобы увидеть, действительно ли сокет доступен для передачи.

~~~
// каждые 100мс проверить сокет и отправить больше данных,
// только если все текущие отосланы
setInterval(() => {
  if (socket.bufferedAmount == 0) {
    socket.send(moreData());
  }
}, 100);
~~~

### Закрытие подключения

Обычно, когда сторона хочет закрыть соединение (браузер и сервер имеют равные права), они отправляют «фрейм закрытия соединения» с кодом закрытия и указывают причину в виде текста.

Метод для этого:

~~~
socket.close([code], [reason]);
~~~

* `code` – специальный WebSocket-код закрытия (не обязателен).
* `reason` – строка с описанием причины закрытия (не обязательна).

Затем противоположная сторона в обработчике события `close` получит и код `code` и причину `reason`, например:

~~~
// закрывающая сторона:
socket.close(1000, "работа закончена");

// другая сторона:
socket.onclose = event => {
  // event.code === 1000
  // event.reason === "работа закончена"
  // event.wasClean === true (закрыто чисто). Все, что отличается от 1000 или 1005, указывает на то, что соединение не было закрыто чисто.
};
~~~

`code` – это не любое число, а специальный код закрытия WebSocket.

Наиболее распространённые значения:

* `1000` – по умолчанию, нормальное закрытие.
* `1006` – невозможно установить такой код вручную, указывает, что соединение было потеряно (нет фрейма закрытия).

Есть и другие коды:

* `1001` – сторона отключилась, например сервер выключен или пользователь покинул страницу.
* `1009` – сообщение слишком большое для обработки.
* `1011` – непредвиденная ошибка на сервере.

…и так далее.

> Любые коды меньше `1000` зарезервированы. Если мы попытаемся установить такой код, то получим ошибку.

### Состояние соединения

Чтобы получить состояние соединения, существует дополнительное свойство `socket.readyState` со значениями:

* `0` – «CONNECTING»: соединение ещё не установлено,
* `1` – «OPEN»: обмен данными,
* `2` – «CLOSING»: соединение закрывается,
* `3` – «CLOSED»: соединение закрыто.

### Пример чата

HTML: нам нужна форма `<form>` для отправки данных и `<div>` для отображения сообщений.

От JavaScript мы хотим 3 вещи:

1. Открыть соединение.
2. При отправке формы пользователем – вызвать `socket.send(message)` для сообщения.
3. При получении входящего сообщения – добавить его в `div#messages`.

Вот код:

~~~
<body>
  <form name="publish">
    <input type="text" name="message" title="message">
    <input type="submit" value="Отправить">
  </form>
  <div id="messages"></div>

  <script>
    const socket = new WebSocket("wss://javascript.info/article/websocket/chat/ws");

    document.forms.publish.onsubmit = function () {
      const outgoingMessage = this.message.value;

      socket.send(outgoingMessage);
      return false;
    };

    socket.onmessage = function (event) {
      const message = event.data;

      const messageElem = document.createElement('div');
      messageElem.textContent = message;
      document.getElementById('messages').prepend(messageElem);
    }
  </script>
</body>
~~~
