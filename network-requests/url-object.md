# ?URL object

Нет сетевых методов, которые требуют именно объект URL, обычные строки вполне подходят. Так что, технически, мы не обязаны использовать URL. Но иногда он может быть весьма удобным.

### Создание URL

Синтаксис создания нового объекта URL:

~~~
new URL(url, [base])
~~~

* `url` – полный URL-адрес или только путь, если указан второй параметр,
* `base` – необязательный «базовый» URL: если указан и аргумент `url` содержит только путь, то адрес будет создан относительно него (пример ниже).

~~~
const url1 = new URL('https://javascript.info/profile/admin');
const url2 = new URL('/profile/admin', 'https://javascript.info');

// {
  hash: "",
  host: "javascript.info",
  hostname: "javascript.info",
  href: "https://javascript.info/profile/admin",
  origin: "https://javascript.info",
  password: "",
  pathname: "/profile/admin",
  port: "",
  protocol: "https:",
  search: "",
};
~~~

![URL object](/images/url-object.png)

* `href` это полный URL-адрес, то же самое, что `url.toString()`
* `protocol` – протокол, заканчивается символом двоеточия `:`
* `search` строка параметров, начинается с вопросительного знака `?`
* `hash` начинается с символа `#`
* также есть свойства `user` и `password`, если используется HTTP-аутентификация: `http://login:password@site.com` (редко используются).

Мы можем использовать объект URL в методах `fetch` или `XMLHttpRequest` и почти во всех других, где ожидается URL-строка.

### searchParams

Иногда параметры должны быть правильно закодированы, чтобы они могли содержать не-латинские буквы, пробелы и т.п.

Так что для этого есть свойство `url.searchParams` – объект типа `URLSearchParams`.

Он предоставляет удобные методы для работы с параметрами:

* `append(name, value)` – добавить параметр по имени.
* `delete(name)` – удалить параметр по имени.
* `get(name)` – получить параметр по имени.
* `getAll(name)` – получить все параметры с одинаковым именем `name` (такое возможно, например: `?user=John&user=Pete`).
* `has(name)` – проверить наличие параметра по имени.
* `set(name, value)` – задать/заменить параметр.
* `sort()` – отсортировать параметры по имени, используется редко.

…и является перебираемым, аналогично `Map`.

~~~
const url = new URL("https://google.com/search");
url.searchParams.set("q", "test me!"); // добавим параметр, содержащий пробел и !

console.log(url.href); // https://google.com/search?q=test+me%21

url.searchParams.set("tbs", "qdr:y"); // параметр с двоеточием :

// параметры автоматически кодируются
console.log(url.href); // https://google.com/search?q=test+me%21&tbs=qdr%3Ay

// перебрать параметры (в исходном виде)
for (let [name, value] of url.searchParams) {
  console.log(`${name}=${value}`); // q=test me!, далее tbs=qdr:y
}

url.searchParams.append("user", "John");
url.searchParams.append("user", "Mary");

console.log(url.searchParams.getAll("user")); // ['John', 'Mary']
~~~

### Кодирование

Существует стандарт `RFC3986`, который определяет список разрешённых и запрещённых символов в URL.

Запрещённые символы, например, нелатинские буквы и пробелы, должны быть закодированы – заменены соответствующими кодами UTF-8 с префиксом `%`, например: `%20` (исторически сложилось так, что пробел в URL-адресе можно также кодировать символом `+`, но это исключение).

К счастью, объекты URL делают всё это автоматически. Мы просто указываем параметры в обычном, незакодированном, виде, а затем конвертируем URL в строку:

~~~
const url = new URL('https://ru.wikipedia.org/wiki/Тест');

console.log(url.href); // https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82
~~~

### Кодирование в строках

Если мы используем для URL-адресов обычные строки, то надо самим позаботиться о кодировании специальных символов.

Для этого есть встроенные функции:

* `encodeURI` – кодирует URL-адрес целиком.
* `decodeURI` – декодирует URL-адрес целиком.
* `encodeURIComponent` – кодирует компонент URL, например, параметр, хеш, имя пути и т.п.
* `decodeURIComponent` – декодирует компонент URL.

Возникает вопрос: «Какая разница между `encodeURIComponent` и `encodeURI`? Когда использовать одну и другую функцию?»

Рассмотрим пример:

~~~
http://site.com:8080/path/page?p1=v1&p2=v2#hash
~~~

Как мы видим, в URL-адресе разрешены символы `:`, `?`, `=`, `&`, `#`.

…С другой стороны, если взглянуть на один компонент, например, URL-параметр, то в нём такие символы должны быть закодированы, чтобы не поломать форматирование.

* `encodeURI` кодирует только символы, полностью запрещённые в URL.
* `encodeURIComponent` кодирует эти же символы плюс, в дополнение к ним, символы `#`, `$`, `&`, `+`, `,`, `/`, `:`, `;`, `=`, `?` и `@`.

Так что для URL целиком можно использовать `encodeURI`:

~~~
const url = encodeURI('http://site.com/привет');

console.log(url); // http://site.com/%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82
~~~

…А для параметров лучше будет взять `encodeURIComponent`:

~~~
const music = encodeURIComponent('Rock&Roll');

const url = `https://google.com/search?q=${music}`;
console.log(url); // https://google.com/search?q=Rock%26Roll
~~~

Сравните с `encodeURI`:

~~~
const music = encodeURI('Rock&Roll');

const url = `https://google.com/search?q=${music}`;
console.log(url); // https://google.com/search?q=Rock&Roll
~~~

Как видим, функция `encodeURI` не закодировала символ `&`, который является разрешённым в составе полного URL-адреса.

Но внутри параметра поиска символ `&` должен быть закодирован, в противном случае мы получим `q=Rock&Roll`, что значит `q=Rock` плюс непонятный параметр `Roll`. Не то, что предполагалось.

Классы `URL` и `URLSearchParams` базируются на последней спецификации URI, описывающей устройство адресов: `RFC3986`, в то время как функции `encode*` – на устаревшей версии стандарта `RFC2396`.

Различий мало, но они есть, например, по-разному кодируются адреса IPv6:

~~~
// допустимый URL-адрес IPv6
const url = 'http://[2607:f8b0:4005:802::1007]/';

console.log(encodeURI(url)); // http://%5B2607:f8b0:4005:802::1007%5D/
console.log(new URL(url).href); // http://[2607:f8b0:4005:802::1007]/
~~~

Как мы видим, функция `encodeURI` заменила квадратные скобки `[...]`, сделав адрес некорректным. Причина: URL-адреса IPv6 не существовали в момент создания стандарта `RFC2396` (август 1998).

Тем не менее, такие случаи редки. По большей части функции `encode*` работают хорошо.
